"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var assert = require("assert");
var index_1 = require("../../../lib/cjs/index");
var Rx = require("rxjs");
require("rxjs/add/operator/mergeAll");
require("rxjs/add/operator/switchMap");
var Cycle = require("@cycle/rxjs-run");
var isolate_1 = require("@cycle/isolate");
function run(uri) {
    describe('makeHTTPDriver', function () {
        it('should be a driver factory', function () {
            assert.strictEqual(typeof index_1.makeHTTPDriver, 'function');
            var output = index_1.makeHTTPDriver();
            assert.strictEqual(typeof output, 'function');
        });
    });
    describe('HTTP Driver', function () {
        this.timeout(8000);
        it('should throw when request stream emits neither string nor object', function (done) {
            function main(sources) {
                return {
                    HTTP: Rx.Observable.of(123),
                };
            }
            var _a = Cycle.setup(main, { HTTP: index_1.makeHTTPDriver() }), sources = _a.sources, run = _a.run;
            sources.HTTP
                .select()
                .mergeAll()
                .subscribe({
                next: function () {
                    done('next should not be called');
                },
                error: function (err) {
                    assert.strictEqual(err.message, 'Observable of requests given to ' +
                        'HTTP Driver must emit either URL strings or objects with ' +
                        'parameters.');
                    done();
                },
                complete: function () {
                    done('complete should not be called');
                },
            });
            run();
        });
        it('should throw when given options object without url string', function (done) {
            function main(sources) {
                return {
                    HTTP: Rx.Observable.of({ method: 'post' }),
                };
            }
            var _a = Cycle.setup(main, { HTTP: index_1.makeHTTPDriver() }), sources = _a.sources, run = _a.run;
            sources.HTTP
                .select()
                .mergeAll()
                .subscribe({
                next: function () {
                    done('next should not be called');
                },
                error: function (err) {
                    assert.strictEqual(err.message, 'Please provide a `url` property in the request ' + 'options.');
                    done();
                },
                complete: function () {
                    done('complete should not be called');
                },
            });
            run();
        });
        it('should return response metastream when given a simple URL string', function (done) {
            function main(sources) {
                return {
                    HTTP: Rx.Observable.of(uri + '/hello'),
                };
            }
            var _a = Cycle.setup(main, { HTTP: index_1.makeHTTPDriver() }), sources = _a.sources, run = _a.run;
            var response$$ = sources.HTTP.select();
            assert.strictEqual(typeof response$$.switchMap, 'function'); // is RxJS v5
            response$$.subscribe({
                next: function (response$) {
                    assert.strictEqual(typeof response$.request, 'object');
                    assert.strictEqual(response$.request.url, uri + '/hello');
                    assert.strictEqual(typeof response$.switchMap, 'function'); // is RxJS v5
                    response$.subscribe(function (response) {
                        assert.strictEqual(response.status, 200);
                        assert.strictEqual(response.text, 'Hello World');
                        done();
                    });
                },
            });
            run();
        });
        it('should return HTTPSource with isolateSource and isolateSink', function (done) {
            function main(sources) {
                return {
                    HTTP: Rx.Observable.of(uri + '/hello'),
                };
            }
            var _a = Cycle.setup(main, { HTTP: index_1.makeHTTPDriver() }), sources = _a.sources, run = _a.run;
            var httpSource = sources.HTTP;
            run();
            assert.strictEqual(typeof sources.HTTP.isolateSource, 'function');
            assert.strictEqual(typeof sources.HTTP.isolateSink, 'function');
            done();
        });
        it('should return response metastream when given simple options obj', function (done) {
            function main(sources) {
                return {
                    HTTP: Rx.Observable.of({
                        url: uri + '/pet',
                        method: 'POST',
                        send: { name: 'Woof', species: 'Dog' },
                    }),
                };
            }
            var _a = Cycle.setup(main, { HTTP: index_1.makeHTTPDriver() }), sources = _a.sources, run = _a.run;
            var response$$ = sources.HTTP.select();
            response$$.subscribe(function (response$) {
                assert.strictEqual(response$.request.url, uri + '/pet');
                assert.strictEqual(response$.request.method, 'POST');
                assert.strictEqual(response$.request.send.name, 'Woof');
                assert.strictEqual(response$.request.send.species, 'Dog');
                response$.subscribe(function (response) {
                    assert.strictEqual(response.status, 200);
                    assert.strictEqual(response.text, 'added Woof the Dog');
                    done();
                });
            });
            run();
        });
        it('should return response metastream when send with type string [#674]', function (done) {
            function main(sources) {
                return {
                    HTTP: Rx.Observable.of({
                        url: uri + '/pet',
                        method: 'POST',
                        send: 'name=Woof&species=Dog',
                    }),
                };
            }
            var _a = Cycle.setup(main, { HTTP: index_1.makeHTTPDriver() }), sources = _a.sources, run = _a.run;
            var response$$ = sources.HTTP.select();
            response$$.subscribe(function (response$) {
                assert.strictEqual(response$.request.url, uri + '/pet');
                assert.strictEqual(response$.request.method, 'POST');
                assert.strictEqual(response$.request.send, 'name=Woof&species=Dog');
                response$.subscribe(function (response) {
                    assert.strictEqual(response.status, 200);
                    assert.strictEqual(response.text, 'added Woof the Dog');
                    done();
                });
            });
            run();
        });
        it('should have DevTools flag in select() source stream', function (done) {
            function main(sources) {
                return {
                    HTTP: Rx.Observable.of({
                        url: uri + '/pet',
                        method: 'POST',
                        send: { name: 'Woof', species: 'Dog' },
                    }),
                };
            }
            var _a = Cycle.setup(main, { HTTP: index_1.makeHTTPDriver() }), sources = _a.sources, run = _a.run;
            var response$$ = sources.HTTP.select();
            assert.strictEqual(response$$._isCycleSource, 'HTTP');
            done();
            run();
        });
        it('should have DevTools flag in response$$ source stream', function (done) {
            function main(sources) {
                return {
                    HTTP: Rx.Observable.of({
                        url: uri + '/pet',
                        method: 'POST',
                        send: { name: 'Woof', species: 'Dog' },
                    }),
                };
            }
            var _a = Cycle.setup(main, { HTTP: index_1.makeHTTPDriver() }), sources = _a.sources, run = _a.run;
            var response$$ = sources.HTTP.select();
            assert.strictEqual(response$$._isCycleSource, 'HTTP');
            done();
            run();
        });
        it('should return response metastream when given another options obj', function (done) {
            function main(sources) {
                return {
                    HTTP: Rx.Observable.of({
                        url: uri + '/querystring',
                        method: 'GET',
                        query: { foo: 102030, bar: 'Pub' },
                    }),
                };
            }
            var _a = Cycle.setup(main, { HTTP: index_1.makeHTTPDriver() }), sources = _a.sources, run = _a.run;
            var response$$ = sources.HTTP.select();
            response$$.subscribe(function (response$) {
                assert.strictEqual(response$.request.url, uri + '/querystring');
                assert.strictEqual(response$.request.method, 'GET');
                assert.strictEqual(response$.request.query.foo, 102030);
                assert.strictEqual(response$.request.query.bar, 'Pub');
                response$.subscribe(function (response) {
                    assert.strictEqual(response.status, 200);
                    assert.strictEqual(response.body.foo, '102030');
                    assert.strictEqual(response.body.bar, 'Pub');
                    done();
                });
            });
            run();
        });
        it('should return response metastream when given yet another options obj', function (done) {
            function main(sources) {
                return {
                    HTTP: Rx.Observable.of({
                        url: uri + '/delete',
                        method: 'DELETE',
                        query: { foo: 102030, bar: 'Pub' },
                    }),
                };
            }
            var _a = Cycle.setup(main, { HTTP: index_1.makeHTTPDriver() }), sources = _a.sources, run = _a.run;
            var response$$ = sources.HTTP.select();
            response$$.subscribe(function (response$) {
                assert.strictEqual(response$.request.url, uri + '/delete');
                assert.strictEqual(response$.request.method, 'DELETE');
                response$.subscribe(function (response) {
                    assert.strictEqual(response.status, 200);
                    assert.strictEqual(response.body.deleted, true);
                    done();
                });
            });
            run();
        });
        it("should not be possible to change the metastream's request", function (done) {
            function main(sources) {
                return {
                    HTTP: Rx.Observable.of({
                        url: uri + '/hello',
                        method: 'GET',
                    }),
                };
            }
            var _a = Cycle.setup(main, { HTTP: index_1.makeHTTPDriver() }), sources = _a.sources, run = _a.run;
            sources.HTTP
                .select()
                .map(function (response$) {
                response$.request = 1234;
                return response$;
            })
                .subscribe(function next(response$) {
                done('next should not be called');
            }, function (err) {
                assert.strictEqual(err instanceof TypeError, true);
                done();
            });
            run();
        });
        it('should send 500 server errors to response$ onError', function (done) {
            function main(sources) {
                return {
                    HTTP: Rx.Observable.of(uri + '/error'),
                };
            }
            var _a = Cycle.setup(main, { HTTP: index_1.makeHTTPDriver() }), sources = _a.sources, run = _a.run;
            var response$$ = sources.HTTP.select();
            response$$.subscribe(function (response$) {
                assert.strictEqual(typeof response$.request, 'object');
                assert.strictEqual(response$.request.url, uri + '/error');
                response$.subscribe({
                    next: function () {
                        done('next should not be called');
                    },
                    error: function (err) {
                        assert.strictEqual(err.status, 500);
                        assert.strictEqual(err.message, 'Internal Server Error');
                        assert.strictEqual(err.response.text, 'boom');
                        done();
                    },
                    complete: function () {
                        done('complete should not be called');
                    },
                });
            });
            run();
        });
        it('should not be sensitive to ordering of sinks (issue #476)', function (done) {
            function main(sources) {
                var request$ = Rx.Observable.of({
                    url: uri + '/hello',
                    method: 'GET',
                });
                var str$ = sources.HTTP
                    .select()
                    .mergeAll()
                    .map(function (res) { return res.text; });
                // Notice HTTP comes before Test here. This is crucial for this test.
                return {
                    HTTP: request$,
                    Test: str$,
                };
            }
            var testDriverExpected = ['Hello World'];
            function testDriver(sink) {
                sink.subscribe({
                    next: function (x) {
                        assert.strictEqual(testDriverExpected.length, 1);
                        assert.strictEqual(x, testDriverExpected.shift());
                        assert.strictEqual(testDriverExpected.length, 0);
                        done();
                    },
                });
            }
            var _a = Cycle.setup(main, {
                HTTP: index_1.makeHTTPDriver(),
                Test: testDriver,
            }), sources = _a.sources, run = _a.run;
            run();
        });
    });
    describe('isolateSource and isolateSink', function () {
        it('should exist on the HTTPSource', function (done) {
            function main(sources) {
                return {
                    HTTP: new Rx.Subject(),
                };
            }
            var _a = Cycle.setup(main, { HTTP: index_1.makeHTTPDriver() }), sources = _a.sources, run = _a.run;
            assert.strictEqual(typeof sources.HTTP.isolateSource, 'function');
            assert.strictEqual(typeof sources.HTTP.isolateSink, 'function');
            done();
        });
        it('should exist on a scoped HTTPSource', function (done) {
            function main(sources) {
                return {
                    HTTP: new Rx.Subject(),
                };
            }
            var _a = Cycle.setup(main, { HTTP: index_1.makeHTTPDriver() }), sources = _a.sources, run = _a.run;
            var scopedHTTPSource = sources.HTTP.isolateSource(sources.HTTP, 'foo');
            assert.strictEqual(typeof scopedHTTPSource.isolateSource, 'function');
            assert.strictEqual(typeof scopedHTTPSource.isolateSink, 'function');
            done();
        });
        it('should hide responses from outside the scope', function (done) {
            var proxyRequest$ = new Rx.Subject();
            function main(sources) {
                return {
                    HTTP: proxyRequest$,
                };
            }
            var _a = Cycle.setup(main, { HTTP: index_1.makeHTTPDriver() }), sources = _a.sources, run = _a.run;
            var ignoredRequest$ = Rx.Observable.of(uri + '/json');
            var request$ = Rx.Observable.of(uri + '/hello').delay(10);
            var scopedRequest$ = sources.HTTP.isolateSink(request$, 'foo');
            var scopedHTTPSource = sources.HTTP.isolateSource(sources.HTTP, 'foo');
            scopedHTTPSource.select().subscribe(function (response$) {
                assert.strictEqual(typeof response$.request, 'object');
                assert.strictEqual(response$.request.url, uri + '/hello');
                response$.subscribe(function (response) {
                    assert.strictEqual(response.status, 200);
                    assert.strictEqual(response.text, 'Hello World');
                    done();
                });
            });
            Rx.Observable
                .merge(ignoredRequest$, scopedRequest$)
                .subscribe(proxyRequest$);
            run();
        });
        it('should hide responses even if using the same scope multiple times', function (done) {
            var proxyRequest$ = new Rx.Subject();
            function main(sources) {
                return {
                    HTTP: proxyRequest$,
                };
            }
            var _a = Cycle.setup(main, { HTTP: index_1.makeHTTPDriver() }), sources = _a.sources, run = _a.run;
            var ignoredRequest$ = Rx.Observable.of(uri + '/json');
            var request$ = Rx.Observable.of(uri + '/hello').delay(10);
            var fooInsideBarRequest$ = sources.HTTP
                .isolateSink(sources.HTTP.isolateSink(request$, 'foo'), 'bar')
                .shareReplay();
            var fooInsideBarHTTPSource = sources.HTTP.isolateSource(sources.HTTP.isolateSource(sources.HTTP, 'bar'), 'foo');
            var fooInsideFooHTTPSource = sources.HTTP.isolateSource(sources.HTTP.isolateSource(sources.HTTP, 'foo'), 'foo');
            fooInsideFooHTTPSource.select().subscribe(function (response$) {
                assert(false);
                done('should not be called');
            });
            fooInsideBarHTTPSource.select().subscribe(function (response$) {
                assert.strictEqual(typeof response$.request, 'object');
                assert.strictEqual(response$.request.url, uri + '/hello');
                response$.subscribe(function (response) {
                    assert.strictEqual(response.status, 200);
                    assert.strictEqual(response.text, 'Hello World');
                    done();
                });
            });
            Rx.Observable
                .merge(ignoredRequest$, fooInsideBarRequest$)
                .subscribe(proxyRequest$);
            run();
        });
        it('should emit responses when isolated many scopes deep', function (done) {
            var dispose;
            function main(sources) {
                sources.HTTP.select('hello').subscribe(function (response$) {
                    assert.strictEqual(typeof response$.request, 'object');
                    assert.strictEqual(response$.request.url, uri + '/hello');
                    response$.subscribe(function (response) {
                        assert.strictEqual(response.status, 200);
                        assert.strictEqual(response.text, 'Hello World');
                        dispose();
                        done();
                    });
                });
                return {
                    HTTP: Rx.Observable
                        .of({ url: uri + '/hello', category: 'hello' })
                        .delay(10),
                };
            }
            function wrapper1(sources) {
                return isolate_1.default(main, { HTTP: 'wrapper1' })(sources);
            }
            function wrapper2(sources) {
                return isolate_1.default(wrapper1, { HTTP: 'wrapper2' })(sources);
            }
            var _a = Cycle.setup(wrapper2, { HTTP: index_1.makeHTTPDriver() }), sources = _a.sources, run = _a.run;
            dispose = run();
        });
        it('should allow null scope to bypass isolation', function (done) {
            var proxyRequest$ = new Rx.Subject();
            function main(sources) {
                return {
                    HTTP: proxyRequest$,
                };
            }
            var _a = Cycle.setup(main, { HTTP: index_1.makeHTTPDriver() }), sources = _a.sources, run = _a.run;
            var ignoredRequest$ = Rx.Observable.of(uri + '/json');
            var request$ = Rx.Observable.of(uri + '/hello').delay(100);
            var scopedRequest$ = sources.HTTP.isolateSink(proxyRequest$, null);
            var scopedHTTPSource = sources.HTTP.isolateSource(sources.HTTP, null);
            var expected = [uri + '/json', uri + '/hello'];
            scopedHTTPSource.select().subscribe(function (response$) {
                assert.strictEqual(typeof response$.request, 'object');
                assert.strictEqual(response$.request.url, expected.shift());
                if (expected.length === 0) {
                    done();
                }
            });
            run();
            Rx.Observable.merge(ignoredRequest$, request$).subscribe(proxyRequest$);
        });
    });
}
exports.run = run;
