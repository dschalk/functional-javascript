"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var assert = require("assert");
var Rx = require("rxjs");
var Cycle = require("@cycle/rxjs-run");
var index_1 = require("../../../lib/cjs/index");
var common_1 = require("./common");
var uri = '//' + window.location.host;
common_1.run(uri);
global.mocha.globals(['Cyclejs']);
describe('HTTP Driver in the browser', function () {
    it('should be able to emit progress events on the response stream', function (done) {
        function main(sources) {
            return {
                HTTP: Rx.Observable.of({
                    url: uri + '/querystring',
                    method: 'GET',
                    progress: true,
                    query: { foo: 102030, bar: 'Pub' },
                }),
            };
        }
        var _a = Cycle.setup(main, { HTTP: index_1.makeHTTPDriver() }), sources = _a.sources, run = _a.run;
        var response$$ = sources.HTTP.select();
        response$$.subscribe({
            next: function (response$) {
                assert.strictEqual(response$.request.url, uri + '/querystring');
                assert.strictEqual(response$.request.method, 'GET');
                assert.strictEqual(response$.request.query.foo, 102030);
                assert.strictEqual(response$.request.query.bar, 'Pub');
                var progressEventHappened = false;
                response$.subscribe(function (response) {
                    if (response.type === 'progress') {
                        assert.strictEqual(typeof response.total, 'number');
                        progressEventHappened = true;
                    }
                    else {
                        assert.strictEqual(progressEventHappened, true);
                        assert.strictEqual(response.status, 200);
                        assert.strictEqual(response.body.foo, '102030');
                        assert.strictEqual(response.body.bar, 'Pub');
                        done();
                    }
                });
            },
        });
        run();
    });
    it('should return binary response when responseType option is arraybuffer', function (done) {
        function main(sources) {
            return {
                HTTP: Rx.Observable.of({
                    url: uri + '/binary',
                    method: 'GET',
                    responseType: 'arraybuffer',
                }),
            };
        }
        var _a = Cycle.setup(main, { HTTP: index_1.makeHTTPDriver() }), sources = _a.sources, run = _a.run;
        var response$$ = sources.HTTP.select();
        response$$.subscribe(function (response$) {
            assert.strictEqual(response$.request.url, uri + '/binary');
            assert.strictEqual(response$.request.method, 'GET');
            assert.strictEqual(response$.request.responseType, 'arraybuffer');
            response$.subscribe(function (response) {
                assert.strictEqual(response.status, 200);
                assert.deepStrictEqual(new Uint8Array(response.body), new Uint8Array([1, 2, 3]));
                done();
            });
        });
        run();
    });
    it('should return binary response when responseType option is blob', function (done) {
        function main(sources) {
            return {
                HTTP: Rx.Observable.of({
                    url: uri + '/binary',
                    method: 'GET',
                    responseType: 'blob',
                }),
            };
        }
        var _a = Cycle.setup(main, { HTTP: index_1.makeHTTPDriver() }), sources = _a.sources, run = _a.run;
        var response$$ = sources.HTTP.select();
        response$$.subscribe(function (response$) {
            assert.strictEqual(response$.request.url, uri + '/binary');
            assert.strictEqual(response$.request.method, 'GET');
            assert.strictEqual(response$.request.responseType, 'blob');
            response$.subscribe(function (response) {
                assert.strictEqual(response.status, 200);
                var fr = new FileReader();
                fr.onload = function (ev) {
                    assert.deepStrictEqual(new Uint8Array(fr.result), new Uint8Array([1, 2, 3]));
                    done();
                };
                fr.onerror = function (ev) {
                    done('should not be called');
                };
                fr.readAsArrayBuffer(response.body);
            });
        });
        run();
    });
    it('should not have cross-driver race conditions (#592)', function (done) {
        this.timeout(10000);
        function child(sources, num) {
            var vdom$ = sources.HTTP
                .select('cat')
                .mergeAll()
                .map(function (res) { return 'My name is ' + res.text; });
            var request$ = num === 1
                ? Rx.Observable.of({
                    category: 'cat',
                    url: uri + '/hello',
                })
                : Rx.Observable.never();
            return {
                HTTP: request$,
                DOM: vdom$,
            };
        }
        function mainHTTPThenDOM(sources) {
            var sinks$ = Rx.Observable
                .interval(500)
                .take(6)
                .map(function (i) {
                if (i % 2 === 1) {
                    return child(sources, i);
                }
                else {
                    return {
                        HTTP: Rx.Observable.empty(),
                        DOM: Rx.Observable.of(''),
                    };
                }
            })
                .publishReplay(1)
                .refCount();
            // order of sinks is important
            return {
                HTTP: sinks$.switchMap(function (sinks) { return sinks.HTTP; }),
                DOM: sinks$.switchMap(function (sinks) { return sinks.DOM; }),
            };
        }
        function mainDOMThenHTTP(sources) {
            var sinks$ = Rx.Observable
                .interval(500)
                .take(6)
                .map(function (i) {
                if (i % 2 === 1) {
                    return child(sources, i);
                }
                else {
                    return {
                        HTTP: Rx.Observable.empty(),
                        DOM: Rx.Observable.of(''),
                    };
                }
            })
                .publishReplay(1)
                .refCount();
            // order of sinks is important
            return {
                DOM: sinks$.switchMap(function (sinks) { return sinks.DOM; }),
                HTTP: sinks$.switchMap(function (sinks) { return sinks.HTTP; }),
            };
        }
        var expectedDOMSinks = [
            /* HTTP then DOM: */ '',
            'My name is Hello World',
            '',
            '',
            /* DOM then HTTP: */ '',
            'My name is Hello World',
            '',
            '',
        ];
        function domDriver(sink) {
            sink.addListener({
                next: function (s) {
                    assert.strictEqual(s, expectedDOMSinks.shift());
                },
                error: function (err) { },
            });
        }
        // HTTP then DOM:
        Cycle.run(mainHTTPThenDOM, {
            HTTP: index_1.makeHTTPDriver(),
            DOM: domDriver,
        });
        setTimeout(function () {
            assert.strictEqual(expectedDOMSinks.length, 4);
            // DOM then HTTP:
            Cycle.run(mainDOMThenHTTP, {
                HTTP: index_1.makeHTTPDriver(),
                DOM: domDriver,
            });
            setTimeout(function () {
                assert.strictEqual(expectedDOMSinks.length, 0);
                done();
            }, 4000);
        }, 4000);
    });
    it('should not remember past responses when selecting', function (done) {
        this.timeout(4000);
        function main(sources) {
            var test$ = Rx.Observable
                .of(null)
                .delay(1000)
                .mergeMap(function () {
                return sources.HTTP
                    .select('cat')
                    .mergeAll()
                    .map(function (res) { return 'I should not show this, ' + res.text; });
            });
            var request$ = Rx.Observable.of({
                category: 'cat',
                url: uri + '/hello',
            });
            return {
                HTTP: request$,
                Test: test$,
            };
        }
        function testDriver(sink) {
            sink.addListener({
                next: function (s) {
                    console.log(s);
                    done('No data should come through the Test sink');
                },
                error: function (err) {
                    done(err);
                },
            });
        }
        Cycle.run(main, {
            HTTP: index_1.makeHTTPDriver(),
            Test: testDriver,
        });
        setTimeout(function () {
            done();
        }, 2000);
    });
});
