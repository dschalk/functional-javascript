{"code":"!function(e){var r={};function t(n){if(r[n])return r[n].exports;var o=r[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,t),o.l=!0,o.exports}t.m=e,t.c=r,t.d=function(e,r,n){t.o(e,r)||Object.defineProperty(e,r,{configurable:!1,enumerable:!0,get:n})},t.r=function(e){Object.defineProperty(e,\"__esModule\",{value:!0})},t.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(r,\"a\",r),r},t.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)},t.p=\"\",t(t.s=0)}([function(e,r){throw new Error(\"Module parse failed: Unterminated string constant (2028:7)\\nYou may need an appropriate loader to handle this file type.\\n|   console.log(b[1]);  // [1,2,3,4]  \\n|   b[0] == b[1]  // true` ),\\n| h('p', ' That didn\\\\'t work! b points to [arr] and arr still points to its original location in memory. \\\"arr.push(4)\\\" mutated the value in arr\\\\'s location and \\\"b.push(arr)\\\" added a copy. \\\"b[0] == b[1]\\\" returning true verifies that both elements of b point to the same place in memory because in JavaScript, the \\\"==\\\" operator on objects (including arrays) is defined to return true if and only if the objects\\\\'    ),\\n| h('p', ' \\\"var arr2 = arr.slice()\\\" is one way \\n| h('pre', `  var arr = [1,2,3];\")}]);","extractedComments":[]}