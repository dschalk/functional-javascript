{"code":"!function(r){var e={};function t(n){if(e[n])return e[n].exports;var o=e[n]={i:n,l:!1,exports:{}};return r[n].call(o.exports,o,o.exports,t),o.l=!0,o.exports}t.m=r,t.c=e,t.d=function(r,e,n){t.o(r,e)||Object.defineProperty(r,e,{configurable:!1,enumerable:!0,get:n})},t.r=function(r){Object.defineProperty(r,\"__esModule\",{value:!0})},t.n=function(r){var e=r&&r.__esModule?function(){return r.default}:function(){return r};return t.d(e,\"a\",e),e},t.o=function(r,e){return Object.prototype.hasOwnProperty.call(r,e)},t.p=\"\",t(t.s=0)}([function(r,e){throw new Error(\"Module parse failed: Unterminated string constant (2029:7)\\nYou may need an appropriate loader to handle this file type.\\n|   b[0] == b[1]  // true` ),\\n| h('p', ' That didn\\\\'t work! b points to [arr] and arr still points to its original location in memory. \\\"arr.push(4)\\\" mutated the value in arr\\\\'s location and \\\"b.push(arr)\\\" added a copy. \\\"b[0] == b[1]\\\" returning true verifies that both elements of b point to the same place in memory because in JavaScript, the \\\"==\\\" operator on objects (including arrays) is defined to return true if and only if the objects\\\\' ' ),\\n| h('p', ' \\\"var arr2 = arr.slice()\\\" is one way \\n| h('pre', `  var arr = [1,2,3];\\n|   var b = [arr.slice()];\")}]);","extractedComments":[]}