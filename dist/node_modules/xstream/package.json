{
  "_from": "xstream",
  "_id": "xstream@11.7.0",
  "_inBundle": false,
  "_integrity": "sha512-wO3TXiQd2/1UZNVsixDIcQgAN6TU4sGH7qIXvs1CRp1kgtkpU8YTfyKt/z/Z1psqcGnR0cJJxHaCnBxtktLx9w==",
  "_location": "/xstream",
  "_phantomChildren": {},
  "_requested": {
    "escapedName": "xstream",
    "fetchSpec": "latest",
    "name": "xstream",
    "raw": "xstream",
    "rawSpec": "",
    "registry": true,
    "saveSpec": null,
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/@cycle/dom",
    "/@cycle/run"
  ],
  "_resolved": "https://registry.npmjs.org/xstream/-/xstream-11.7.0.tgz",
  "_shasum": "6557e9710e1ab05ae28b6902af41745250d32e36",
  "_shrinkwrap": null,
  "_spec": "xstream",
  "_where": "/home/e/TEST/fjTest/dist",
  "author": {
    "email": "andre+npm@staltz.com",
    "name": "Andre Staltz",
    "url": "http://andre.staltz.com/"
  },
  "bugs": {
    "url": "https://github.com/staltz/xstream/issues"
  },
  "bundleDependencies": false,
  "config": {
    "commitizen": {
      "path": "./node_modules/cz-conventional-changelog"
    }
  },
  "dependencies": {
    "symbol-observable": "1.2.0"
  },
  "deprecated": false,
  "description": "An extremely intuitive, small, and fast functional reactive stream library for JavaScript",
  "devDependencies": {
    "@types/mocha": "^2.2.40",
    "@types/node": "^7.0.12",
    "@types/sinon": "^2.1.2",
    "assert": "1.3.x",
    "browserify": "13.0.x",
    "commitizen": "2.9.x",
    "conventional-changelog": "1.1.x",
    "conventional-changelog-cli": "1.2.x",
    "cz-conventional-changelog": "1.2.x",
    "es6-promise": "4.0.5",
    "google-closure-compiler-js": "^20170910.0.0",
    "markdown-doctest": "0.9.1",
    "markdox": "0.1.10",
    "mkdirp": "0.5.1",
    "mocha": "2.4.5",
    "most": "1.0.3",
    "sinon": "1.16.0",
    "strip-comments": "0.4.4",
    "ts-node": "6.0.x",
    "tsify": "4.0.x",
    "tslint": "5.7.0",
    "typescript": "2.8.x",
    "validate-commit-msg": "2.4.x"
  },
  "homepage": "https://github.com/staltz/xstream#readme",
  "license": "MIT",
  "main": "index.js",
  "name": "xstream",
  "optionalDependencies": {},
  "publishConfig": {
    "access": "public"
  },
  "readme": "<!-- This README.md is automatically generated from source code and files in the /markdown directory. Please DO NOT send pull requests to directly modify this README. Instead, edit the JSDoc comments in source code or the md files in /markdown/. -->\n\n```text\n          _\n__  _____| |_ _ __ ___  __ _ _ __ ___\n\\ \\/ / __| __| '__/ _ \\/ _` | '_ ` _ \\\n >  <\\__ \\ |_| | |  __/ (_| | | | | | |\n/_/\\_\\___/\\__|_|  \\___|\\__,_|_| |_| |_|\n```\n<h2 class=\"site-subtitle\">An extremely intuitive, small, and fast<br />functional reactive stream library for JavaScript</h2>\n\n- Only 26 core operators and factories\n- Only [\"hot\"](https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339#.mvzg5e7lf) streams\n- Written in TypeScript\n- Approximately 30 kB in size, when minified\n- On average, faster than RxJS 4, Kefir, Bacon.js, as fast as RxJS 5, and slower than most.js\n- Tailored for [Cycle.js](http://cycle.js.org), or applications with limited use of `subscribe`\n\n![](https://badge-size.herokuapp.com/staltz/xstream/master/dist/xstream.js.svg)\n![](https://badge-size.herokuapp.com/staltz/xstream/master/dist/xstream.min.js.svg?compression=gzip)\n[![ComVer](https://img.shields.io/badge/ComVer-compliant-brightgreen.svg)](https://github.com/staltz/comver)\n[![Gitter](https://img.shields.io/gitter/room/nwjs/nw.js.svg?maxAge=2592000)](https://gitter.im/staltz/xstream)\n\n# Example\n\n```js\nimport xs from 'xstream'\n\n// Tick every second incremental numbers,\n// only pass even numbers, then map them to their square,\n// and stop after 5 seconds has passed\n\nvar stream = xs.periodic(1000)\n  .filter(i => i % 2 === 0)\n  .map(i => i * i)\n  .endWhen(xs.periodic(5000).take(1))\n\n// So far, the stream is idle.\n// As soon as it gets its first listener, it starts executing.\n\nstream.addListener({\n  next: i => console.log(i),\n  error: err => console.error(err),\n  complete: () => console.log('completed'),\n})\n```\n\n# Installation\n\n```text\nnpm install xstream\n```\n\n# Usage\n\n## ES2015 or TypeScript\n\n```js\nimport xs from 'xstream'\n```\n\n## CommonJS\n\n```js\nvar xs = require('xstream').default\n```\n\n# API\n\n## Factories\n- [`create`](#create)\n- [`createWithMemory`](#createWithMemory)\n- [`never`](#never)\n- [`empty`](#empty)\n- [`throw`](#throw)\n- [`from`](#from)\n- [`of`](#of)\n- [`fromArray`](#fromArray)\n- [`fromPromise`](#fromPromise)\n- [`fromObservable`](#fromObservable)\n- [`periodic`](#periodic)\n- [`merge`](#merge)\n- [`combine`](#combine)\n\n## Methods and Operators\n- [`addListener`](#addListener)\n- [`removeListener`](#removeListener)\n- [`subscribe`](#subscribe)\n- [`map`](#map)\n- [`mapTo`](#mapTo)\n- [`filter`](#filter)\n- [`take`](#take)\n- [`drop`](#drop)\n- [`last`](#last)\n- [`startWith`](#startWith)\n- [`endWhen`](#endWhen)\n- [`fold`](#fold)\n- [`replaceError`](#replaceError)\n- [`flatten`](#flatten)\n- [`compose`](#compose)\n- [`remember`](#remember)\n- [`debug`](#debug)\n- [`imitate`](#imitate)\n- [`shamefullySendNext`](#shamefullySendNext)\n- [`shamefullySendError`](#shamefullySendError)\n- [`shamefullySendComplete`](#shamefullySendComplete)\n- [`setDebugListener`](#setDebugListener)\n\n## Extra factories and operators\n\nTo keep the core of xstream small and simple, less frequently-used methods are available under the `xstream/extra` directory, and must be imported separately. See [EXTRA_DOCS](https://github.com/staltz/xstream/blob/master/EXTRA_DOCS.md) for documentation.\n\n# Overview\n\nXStream has four fundamental types: [Stream](#stream), [Listener](#listener), [Producer](#producer), and [MemoryStream](#memorystream).\n\n## Stream\n\nA Stream is an **event emitter** with multiple Listeners. When an event happens on the\nStream, it is broadcast to all its Listeners at the same time.\n\nStreams have methods attached to them called *operators*, such as `map`, `filter`, `fold`, `take`, etc. When called, an operator creates and returns another Stream. Once the first Stream broadcasts an event, the event will pass through the operator logic and the output Stream may perhaps broadcast its own event based on the source one.\n\nYou can also trigger an event to happen on a Stream with the `shamefullySend*` methods. But you don't want to do that. Really, avoid doing that because it's not the reactive way and you'll be missing the point of this library. Ok?\n\n## Listener\n\nA Listener is an object with one to three functions attached to it: `next`, `error`, and `complete`. There is usually one function for each type of event a Stream may emit but only `next` is always required.\n\n- `next` events are the typical type, they deliver a value.\n- `error` events abort (stop) the execution of the Stream, and happen when something goes wrong in the Stream (or upstream somewhere in the chain of operators)\n- `complete` events signal the peaceful stop of the execution of the Stream.\n\nThis is an example of a typical listener:\n\n```js\nvar listener = {\n  next: (value) => {\n    console.log('The Stream gave me a value: ', value);\n  },\n  error: (err) => {\n    console.error('The Stream gave me an error: ', err);\n  },\n  complete: () => {\n    console.log('The Stream told me it is done.');\n  },\n}\n```\n\nAnd this is how you would attach that Listener to a Stream:\n\n<!-- skip-example -->\n```js\nstream.addListener(listener)\n```\n\nAnd when you think the Listener is done, you can remove it from the Stream:\n\n<!-- skip-example -->\n```js\nstream.removeListener(listener)\n```\n\n## Producer\n\nA Producer is like a machine that produces events to be broadcast on a Stream.\n\nEvents from a Stream must come from somewhere, right? That's why we need Producers. They are objects with two functions attached: `start(listener)` and `stop()`. Once you call `start` with a `listener`, the Producer will start generating events and it will send those to the listener. When you call `stop()`, the Producer should quit doing its own thing.\n\nStreams are also Listeners (actually they are \"InternalListeners\", not Listeners, but that's a detail you can ignore), so you can theoretically give a Stream as the listener in `producer.start(streamAsListener)`. Then, essentially the Producer is now generating events that will be broadcast on the Stream. Nice, huh? Now a bunch of listeners can be attached to the Stream and they can all get those events originally coming from the Producer. That's why `xs.create(producer)` receives a Producer to be the heart of a new Stream. Check this out:\n\n```js\nvar producer = {\n  start: function (listener) {\n    this.id = setInterval(() => listener.next('yo'), 1000)\n  },\n\n  stop: function () {\n    clearInterval(this.id)\n  },\n\n  id: 0,\n}\n\n// This fellow delivers a 'yo' next event every 1 second\nvar stream = xs.create(producer)\n```\n\nBut remember, a Producer has only one listener, but a Stream may have many listeners.\n\nYou may wonder \"when is `start` and `stop` called\", and that's actually a fairly tricky topic, so let's get back to that soon. First let me tell you about MemoryStreams.\n\n## MemoryStream\n\nA MemoryStream is just like a Stream: it has operators, it can have listeners attached, you can shamefully send events to it, blabla. But it has one special property: it has *memory*. It remembers the most recent (but just one) `next` event that it sent to its listeners.\n\nWhy is that useful? If a new Listener is added *after* that `next` event was sent, the MemoryStream will get its value stored in memory and will send it to the newly attached Listener.\n\nThis is important so MemoryStreams can represent values or pieces of state which are relevant even after some time has passed. You don't want to lose those, you want to keep them and send them to Listeners that arrive late, after the event was originally created.\n\n## How a Stream starts and stops\n\nA Stream controls its Producer according to its number of Listeners, using reference counting with a synchronous `start` and a cancelable asynchronous `stop`. That's how a Stream starts and stops, basically. Usually this part of XStream is not so relevant to remember when building applications, but if you want to understand it for debugging or curiosity, it's explained in plain English below.\n\nWhen you create a Stream with `xs.create(producer)`, the `start()` function of the Producer is not yet called. The Stream is still \"idle\". It has the Producer, but the Producer was not turned on.\n\nOnce the first Listener is added to the Stream, the number of Listeners attached suddenly changed from `0` to `1`. That's when the Stream calls `start`, because after all there is at least one Listener interested in this Stream.\n\nMore Listeners may be added in the future, but they don't affect whether the Producer will continue working or stop. Just the first Listener dictates when the Stream starts.\n\nWhat matters for stopping the Producer is `stream.removeListener`. When the last Listener leaves (or in other words, when the number of Listeners suddenly changes from `1` to `0`), the Stream schedules `producer.stop()` **to happen on the next event loop**. That is, asynchronously. If, however, a new Listener is added (number goes from `0` to `1`) *before* that scheduled moment, the `producer.stop()` will be cancelled, and the Producer will continue generating events for its Stream normally.\n\nThe reason the Producer is not suddenly (synchronously) stopped, is that it is often necessary to swap the single listener of a Stream, but still keep its ongoing execution. For instance:\n\n<!-- skip-example -->\n```js\nvar listenerA = {/* ... */}\nvar listenerB = {/* ... */}\n\n// number goes from 0 to 1, so the Stream's Producer starts\nstream.addListener(listenerA)\n\n// ...\n\n// number goes from 1 to 0, but then immediately goes back\n// to 1, because listenerB was added\nstream.removeListener(listenerA)\nstream.addListener(listenerB)\n\n// Stream's Producer does not stop, everything continues as before\n```\n\nIt's still useful to eventually (asynchronously) stop a Stream's internal Producer, because you don't want useless computation lying around producing gibberish. At least I don't.\n\n# Factories\n\nFactories are functions that create Streams, such as `xs.create()`, `xs.periodic()`, etc.\n\n### <a id=\"create\"></a> `create(producer)`\n\nCreates a new Stream given a Producer.\n\n#### Arguments:\n\n- `producer: Producer` An optional Producer that dictates how to start, generate events, and stop the Stream.\n\n#### Returns:  Stream \n\n- - -\n\n### <a id=\"createWithMemory\"></a> `createWithMemory(producer)`\n\nCreates a new MemoryStream given a Producer.\n\n#### Arguments:\n\n- `producer: Producer` An optional Producer that dictates how to start, generate events, and stop the Stream.\n\n#### Returns:  MemoryStream \n\n- - -\n\n### <a id=\"never\"></a> `never()`\n\nCreates a Stream that does nothing when started. It never emits any event.\n\nMarble diagram:\n\n```text\n         never\n-----------------------\n```\n\n#### Returns:  Stream \n\n- - -\n\n### <a id=\"empty\"></a> `empty()`\n\nCreates a Stream that immediately emits the \"complete\" notification when\nstarted, and that's it.\n\nMarble diagram:\n\n```text\nempty\n-|\n```\n\n#### Returns:  Stream \n\n- - -\n\n### <a id=\"throw\"></a> `throw(error)`\n\nCreates a Stream that immediately emits an \"error\" notification with the\nvalue you passed as the `error` argument when the stream starts, and that's\nit.\n\nMarble diagram:\n\n```text\nthrow(X)\n-X\n```\n\n#### Arguments:\n\n- `error` The error event to emit on the created stream.\n\n#### Returns:  Stream \n\n- - -\n\n### <a id=\"from\"></a> `from(input)`\n\nCreates a stream from an Array, Promise, or an Observable.\n\n#### Arguments:\n\n- `input: Array|PromiseLike|Observable` The input to make a stream from.\n\n#### Returns:  Stream \n\n- - -\n\n### <a id=\"of\"></a> `of(a, b)`\n\nCreates a Stream that immediately emits the arguments that you give to\n*of*, then completes.\n\nMarble diagram:\n\n```text\nof(1,2,3)\n123|\n```\n\n#### Arguments:\n\n- `a` The first value you want to emit as an event on the stream.\n- `b` The second value you want to emit as an event on the stream. One or more of these values may be given as arguments.\n\n#### Returns:  Stream \n\n- - -\n\n### <a id=\"fromArray\"></a> `fromArray(array)`\n\nConverts an array to a stream. The returned stream will emit synchronously\nall the items in the array, and then complete.\n\nMarble diagram:\n\n```text\nfromArray([1,2,3])\n123|\n```\n\n#### Arguments:\n\n- `array: Array` The array to be converted as a stream.\n\n#### Returns:  Stream \n\n- - -\n\n### <a id=\"fromPromise\"></a> `fromPromise(promise)`\n\nConverts a promise to a stream. The returned stream will emit the resolved\nvalue of the promise, and then complete. However, if the promise is\nrejected, the stream will emit the corresponding error.\n\nMarble diagram:\n\n```text\nfromPromise( ----42 )\n-----------------42|\n```\n\n#### Arguments:\n\n- `promise: PromiseLike` The promise to be converted as a stream.\n\n#### Returns:  Stream \n\n- - -\n\n### <a id=\"fromObservable\"></a> `fromObservable(observable)`\n\nConverts an Observable into a Stream.\n\n#### Arguments:\n\n- `observable: any` The observable to be converted as a stream.\n\n#### Returns:  Stream \n\n- - -\n\n### <a id=\"periodic\"></a> `periodic(period)`\n\nCreates a stream that periodically emits incremental numbers, every\n`period` milliseconds.\n\nMarble diagram:\n\n```text\n    periodic(1000)\n---0---1---2---3---4---...\n```\n\n#### Arguments:\n\n- `period: number` The interval in milliseconds to use as a rate of emission.\n\n#### Returns:  Stream \n\n- - -\n\n### <a id=\"merge\"></a> `merge(stream1, stream2)`\n\nBlends multiple streams together, emitting events from all of them\nconcurrently.\n\n*merge* takes multiple streams as arguments, and creates a stream that\nbehaves like each of the argument streams, in parallel.\n\nMarble diagram:\n\n```text\n--1----2-----3--------4---\n----a-----b----c---d------\n           merge\n--1-a--2--b--3-c---d--4---\n```\n\n#### Arguments:\n\n- `stream1: Stream` A stream to merge together with other streams.\n- `stream2: Stream` A stream to merge together with other streams. Two or more streams may be given as arguments.\n\n#### Returns:  Stream \n\n- - -\n\n### <a id=\"combine\"></a> `combine(stream1, stream2)`\n\nCombines multiple input streams together to return a stream whose events\nare arrays that collect the latest events from each input stream.\n\n*combine* internally remembers the most recent event from each of the input\nstreams. When any of the input streams emits an event, that event together\nwith all the other saved events are combined into an array. That array will\nbe emitted on the output stream. It's essentially a way of joining together\nthe events from multiple streams.\n\nMarble diagram:\n\n```text\n--1----2-----3--------4---\n----a-----b-----c--d------\n         combine\n----1a-2a-2b-3b-3c-3d-4d--\n```\n\n#### Arguments:\n\n- `stream1: Stream` A stream to combine together with other streams.\n- `stream2: Stream` A stream to combine together with other streams. Multiple streams, not just two, may be given as arguments.\n\n#### Returns:  Stream \n\n- - -\n\n\n# Methods and Operators\n\nMethods are functions attached to a Stream instance, like `stream.addListener()`. Operators are also methods, but return a new Stream, leaving the existing Stream unmodified, except for the fact that it has a child Stream attached as Listener.\n\n### <a id=\"addListener\"></a> `addListener(listener)`\n\nAdds a Listener to the Stream.\n\n#### Arguments:\n\n- `listener: Listener`\n\n- - -\n\n### <a id=\"removeListener\"></a> `removeListener(listener)`\n\nRemoves a Listener from the Stream, assuming the Listener was added to it.\n\n#### Arguments:\n\n- `listener: Listener\\<T>`\n\n- - -\n\n### <a id=\"subscribe\"></a> `subscribe(listener)`\n\nAdds a Listener to the Stream returning a Subscription to remove that\nlistener.\n\n#### Arguments:\n\n- `listener: Listener`\n\n#### Returns:  Subscription \n\n- - -\n\n### <a id=\"map\"></a> `map(project)`\n\nTransforms each event from the input Stream through a `project` function,\nto get a Stream that emits those transformed events.\n\nMarble diagram:\n\n```text\n--1---3--5-----7------\n   map(i => i * 10)\n--10--30-50----70-----\n```\n\n#### Arguments:\n\n- `project: Function` A function of type `(t: T) => U` that takes event `t` of type `T` from the input Stream and produces an event of type `U`, to\nbe emitted on the output Stream.\n\n#### Returns:  Stream \n\n- - -\n\n### <a id=\"mapTo\"></a> `mapTo(projectedValue)`\n\nIt's like `map`, but transforms each input event to always the same\nconstant value on the output Stream.\n\nMarble diagram:\n\n```text\n--1---3--5-----7-----\n      mapTo(10)\n--10--10-10----10----\n```\n\n#### Arguments:\n\n- `projectedValue` A value to emit on the output Stream whenever the input Stream emits any value.\n\n#### Returns:  Stream \n\n- - -\n\n### <a id=\"filter\"></a> `filter(passes)`\n\nOnly allows events that pass the test given by the `passes` argument.\n\nEach event from the input stream is given to the `passes` function. If the\nfunction returns `true`, the event is forwarded to the output stream,\notherwise it is ignored and not forwarded.\n\nMarble diagram:\n\n```text\n--1---2--3-----4-----5---6--7-8--\n    filter(i => i % 2 === 0)\n------2--------4---------6----8--\n```\n\n#### Arguments:\n\n- `passes: Function` A function of type `(t: T) => boolean` that takes an event from the input stream and checks if it passes, by returning a\nboolean.\n\n#### Returns:  Stream \n\n- - -\n\n### <a id=\"take\"></a> `take(amount)`\n\nLets the first `amount` many events from the input stream pass to the\noutput stream, then makes the output stream complete.\n\nMarble diagram:\n\n```text\n--a---b--c----d---e--\n   take(3)\n--a---b--c|\n```\n\n#### Arguments:\n\n- `amount: number` How many events to allow from the input stream before completing the output stream.\n\n#### Returns:  Stream \n\n- - -\n\n### <a id=\"drop\"></a> `drop(amount)`\n\nIgnores the first `amount` many events from the input stream, and then\nafter that starts forwarding events from the input stream to the output\nstream.\n\nMarble diagram:\n\n```text\n--a---b--c----d---e--\n      drop(3)\n--------------d---e--\n```\n\n#### Arguments:\n\n- `amount: number` How many events to ignore from the input stream before forwarding all events from the input stream to the output stream.\n\n#### Returns:  Stream \n\n- - -\n\n### <a id=\"last\"></a> `last()`\n\nWhen the input stream completes, the output stream will emit the last event\nemitted by the input stream, and then will also complete.\n\nMarble diagram:\n\n```text\n--a---b--c--d----|\n      last()\n-----------------d|\n```\n\n#### Returns:  Stream \n\n- - -\n\n### <a id=\"startWith\"></a> `startWith(initial)`\n\nPrepends the given `initial` value to the sequence of events emitted by the\ninput stream. The returned stream is a MemoryStream, which means it is\nalready `remember()`'d.\n\nMarble diagram:\n\n```text\n---1---2-----3---\n  startWith(0)\n0--1---2-----3---\n```\n\n#### Arguments:\n\n- `initial` The value or event to prepend.\n\n#### Returns:  MemoryStream \n\n- - -\n\n### <a id=\"endWhen\"></a> `endWhen(other)`\n\nUses another stream to determine when to complete the current stream.\n\nWhen the given `other` stream emits an event or completes, the output\nstream will complete. Before that happens, the output stream will behaves\nlike the input stream.\n\nMarble diagram:\n\n```text\n---1---2-----3--4----5----6---\n  endWhen( --------a--b--| )\n---1---2-----3--4--|\n```\n\n#### Arguments:\n\n- `other` Some other stream that is used to know when should the output stream of this operator complete.\n\n#### Returns:  Stream \n\n- - -\n\n### <a id=\"fold\"></a> `fold(accumulate, seed)`\n\n\"Folds\" the stream onto itself.\n\nCombines events from the past throughout\nthe entire execution of the input stream, allowing you to accumulate them\ntogether. It's essentially like `Array.prototype.reduce`. The returned\nstream is a MemoryStream, which means it is already `remember()`'d.\n\nThe output stream starts by emitting the `seed` which you give as argument.\nThen, when an event happens on the input stream, it is combined with that\nseed value through the `accumulate` function, and the output value is\nemitted on the output stream. `fold` remembers that output value as `acc`\n(\"accumulator\"), and then when a new input event `t` happens, `acc` will be\ncombined with that to produce the new `acc` and so forth.\n\nMarble diagram:\n\n```text\n------1-----1--2----1----1------\n  fold((acc, x) => acc + x, 3)\n3-----4-----5--7----8----9------\n```\n\n#### Arguments:\n\n- `accumulate: Function` A function of type `(acc: R, t: T) => R` that takes the previous accumulated value `acc` and the incoming event from the\ninput stream and produces the new accumulated value.\n- `seed` The initial accumulated value, of type `R`.\n\n#### Returns:  MemoryStream \n\n- - -\n\n### <a id=\"replaceError\"></a> `replaceError(replace)`\n\nReplaces an error with another stream.\n\nWhen (and if) an error happens on the input stream, instead of forwarding\nthat error to the output stream, *replaceError* will call the `replace`\nfunction which returns the stream that the output stream will replicate.\nAnd, in case that new stream also emits an error, `replace` will be called\nagain to get another stream to start replicating.\n\nMarble diagram:\n\n```text\n--1---2-----3--4-----X\n  replaceError( () => --10--| )\n--1---2-----3--4--------10--|\n```\n\n#### Arguments:\n\n- `replace: Function` A function of type `(err) => Stream` that takes the error that occurred on the input stream or on the previous replacement\nstream and returns a new stream. The output stream will behave like the\nstream that this function returns.\n\n#### Returns:  Stream \n\n- - -\n\n### <a id=\"flatten\"></a> `flatten()`\n\nFlattens a \"stream of streams\", handling only one nested stream at a time\n(no concurrency).\n\nIf the input stream is a stream that emits streams, then this operator will\nreturn an output stream which is a flat stream: emits regular events. The\nflattening happens without concurrency. It works like this: when the input\nstream emits a nested stream, *flatten* will start imitating that nested\none. However, as soon as the next nested stream is emitted on the input\nstream, *flatten* will forget the previous nested one it was imitating, and\nwill start imitating the new nested one.\n\nMarble diagram:\n\n```text\n--+--------+---------------\n  \\        \\\n   \\       ----1----2---3--\n   --a--b----c----d--------\n          flatten\n-----a--b------1----2---3--\n```\n\n#### Returns:  Stream \n\n- - -\n\n### <a id=\"compose\"></a> `compose(operator)`\n\nPasses the input stream to a custom operator, to produce an output stream.\n\n*compose* is a handy way of using an existing function in a chained style.\nInstead of writing `outStream = f(inStream)` you can write\n`outStream = inStream.compose(f)`.\n\n#### Arguments:\n\n- `operator: function` A function that takes a stream as input and returns a stream as well.\n\n#### Returns:  Stream \n\n- - -\n\n### <a id=\"remember\"></a> `remember()`\n\nReturns an output stream that behaves like the input stream, but also\nremembers the most recent event that happens on the input stream, so that a\nnewly added listener will immediately receive that memorised event.\n\n#### Returns:  MemoryStream \n\n- - -\n\n### <a id=\"debug\"></a> `debug(labelOrSpy)`\n\nReturns an output stream that identically behaves like the input stream,\nbut also runs a `spy` function for each event, to help you debug your app.\n\n*debug* takes a `spy` function as argument, and runs that for each event\nhappening on the input stream. If you don't provide the `spy` argument,\nthen *debug* will just `console.log` each event. This helps you to\nunderstand the flow of events through some operator chain.\n\nPlease note that if the output stream has no listeners, then it will not\nstart, which means `spy` will never run because no actual event happens in\nthat case.\n\nMarble diagram:\n\n```text\n--1----2-----3-----4--\n        debug\n--1----2-----3-----4--\n```\n\n#### Arguments:\n\n- `labelOrSpy: function` A string to use as the label when printing debug information on the console, or a 'spy' function that takes an event\nas argument, and does not need to return anything.\n\n#### Returns:  Stream \n\n- - -\n\n### <a id=\"imitate\"></a> `imitate(target)`\n\n*imitate* changes this current Stream to emit the same events that the\n`other` given Stream does. This method returns nothing.\n\nThis method exists to allow one thing: **circular dependency of streams**.\nFor instance, let's imagine that for some reason you need to create a\ncircular dependency where stream `first$` depends on stream `second$`\nwhich in turn depends on `first$`:\n\n<!-- skip-example -->\n```js\nimport delay from 'xstream/extra/delay'\n\nvar first$ = second$.map(x => x * 10).take(3);\nvar second$ = first$.map(x => x + 1).startWith(1).compose(delay(100));\n```\n\nHowever, that is invalid JavaScript, because `second$` is undefined\non the first line. This is how *imitate* can help solve it:\n\n```js\nimport delay from 'xstream/extra/delay'\n\nvar secondProxy$ = xs.create();\nvar first$ = secondProxy$.map(x => x * 10).take(3);\nvar second$ = first$.map(x => x + 1).startWith(1).compose(delay(100));\nsecondProxy$.imitate(second$);\n```\n\nWe create `secondProxy$` before the others, so it can be used in the\ndeclaration of `first$`. Then, after both `first$` and `second$` are\ndefined, we hook `secondProxy$` with `second$` with `imitate()` to tell\nthat they are \"the same\". `imitate` will not trigger the start of any\nstream, it just binds `secondProxy$` and `second$` together.\n\nThe following is an example where `imitate()` is important in Cycle.js\napplications. A parent component contains some child components. A child\nhas an action stream which is given to the parent to define its state:\n\n<!-- skip-example -->\n```js\nconst childActionProxy$ = xs.create();\nconst parent = Parent({...sources, childAction$: childActionProxy$});\nconst childAction$ = parent.state$.map(s => s.child.action$).flatten();\nchildActionProxy$.imitate(childAction$);\n```\n\nNote, though, that **`imitate()` does not support MemoryStreams**. If we\nwould attempt to imitate a MemoryStream in a circular dependency, we would\neither get a race condition (where the symptom would be \"nothing happens\")\nor an infinite cyclic emission of values. It's useful to think about\nMemoryStreams as cells in a spreadsheet. It doesn't make any sense to\ndefine a spreadsheet cell `A1` with a formula that depends on `B1` and\ncell `B1` defined with a formula that depends on `A1`.\n\nIf you find yourself wanting to use `imitate()` with a\nMemoryStream, you should rework your code around `imitate()` to use a\nStream instead. Look for the stream in the circular dependency that\nrepresents an event stream, and that would be a candidate for creating a\nproxy Stream which then imitates the target Stream.\n\n#### Arguments:\n\n- `target: Stream` The other stream to imitate on the current one. Must not be a MemoryStream.\n\n- - -\n\n### <a id=\"shamefullySendNext\"></a> `shamefullySendNext(value)`\n\nForces the Stream to emit the given value to its listeners.\n\nAs the name indicates, if you use this, you are most likely doing something\nThe Wrong Way. Please try to understand the reactive way before using this\nmethod. Use it only when you know what you are doing.\n\n#### Arguments:\n\n- `value` The \"next\" value you want to broadcast to all listeners of this Stream.\n\n- - -\n\n### <a id=\"shamefullySendError\"></a> `shamefullySendError(error)`\n\nForces the Stream to emit the given error to its listeners.\n\nAs the name indicates, if you use this, you are most likely doing something\nThe Wrong Way. Please try to understand the reactive way before using this\nmethod. Use it only when you know what you are doing.\n\n#### Arguments:\n\n- `error: any` The error you want to broadcast to all the listeners of this Stream.\n\n- - -\n\n### <a id=\"shamefullySendComplete\"></a> `shamefullySendComplete()`\n\nForces the Stream to emit the \"completed\" event to its listeners.\n\nAs the name indicates, if you use this, you are most likely doing something\nThe Wrong Way. Please try to understand the reactive way before using this\nmethod. Use it only when you know what you are doing.\n\n- - -\n\n### <a id=\"setDebugListener\"></a> `setDebugListener(listener)`\n\nAdds a \"debug\" listener to the stream. There can only be one debug\nlistener, that's why this is 'setDebugListener'. To remove the debug\nlistener, just call setDebugListener(null).\n\nA debug listener is like any other listener. The only difference is that a\ndebug listener is \"stealthy\": its presence/absence does not trigger the\nstart/stop of the stream (or the producer inside the stream). This is\nuseful so you can inspect what is going on without changing the behavior\nof the program. If you have an idle stream and you add a normal listener to\nit, the stream will start executing. But if you set a debug listener on an\nidle stream, it won't start executing (not until the first normal listener\nis added).\n\nAs the name indicates, we don't recommend using this method to build app\nlogic. In fact, in most cases the debug operator works just fine. Only use\nthis one if you know what you're doing.\n\n#### Arguments:\n\n- `listener: Listener\\<T>`\n\n- - -\n\n# FAQ\n\n**Q: Why does `imitate()` support a Stream but not a MemoryStream?**\n\nA: MemoryStreams are meant for representing \"values over time\" (your age), while Streams represent simply events (your birthdays). MemoryStreams are usually initialized with a value, and `imitate()` is meant for creating circular dependencies of streams. If we would attempt to imitate a MemoryStream in a circular dependency, we would either get a race condition (where the symptom would be \"nothing happens\") or an infinite cyclic emission of values.\n\nIf you find yourself wanting to use `imitate()` with a MemoryStream, you should rework your code around `imitate()` to use a Stream instead. Look for the stream in the circular dependency that represents an event stream, and that would be a candidate for creating a MimicStream which then imitates the real event stream.\n\n**Q: What's the difference between xstream and RxJS?**\n\nA: Read this [blog post](http://staltz.com/why-we-built-xstream.html) on the topic. In short:\n\n- xstream Streams are multicast always.\n- RxJS Observables are unicast by default, and opt-in multicast.\n- xstream has few operators *as a feature* (helps against decision paralysis).\n- RxJS has many operators *as a feature* (helps for flexibility and power).\n\n**Q: What is the equivalent of [`withLatestFrom`](http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-withLatestFrom) in xstream?**\n\nA: `withLatestFrom` is implemented as an extra named [`sampleCombine`](https://github.com/staltz/xstream/blob/master/EXTRA_DOCS.md#sampleCombine).\n\n-----\n\n# Misc.\n\n## Acknowledgements\n\n*xstream* is built by [staltz](https://github.com/staltz) and [TylorS](https://github.com/tylors).\n\n## CHANGELOG\n\nRead the [CHANGELOG](https://github.com/staltz/xstream/blob/master/CHANGELOG.md) for release notes of all versions of *xstream*.\n\n## License\n\n[MIT](https://github.com/staltz/xstream/blob/master/LICENSE)\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/staltz/xstream.git"
  },
  "scripts": {
    "changelog": "conventional-changelog --infile CHANGELOG.md --same-file --release-count 0 --preset angular",
    "check-release": "node tools/check-release.js",
    "commit": "git-cz",
    "compile": "tsc",
    "dist": "browserify index.js --standalone xstream | node tools/strip-comments.js > dist/xstream.js",
    "doctest": "markdown-doctest",
    "extra-docs": "node tools/make-extras.js && rm EXTRA_DOCS.md && cp markdown/generated-extras.md EXTRA_DOCS.md",
    "lint": "tslint -c tslint.json src/**/*.ts src/extra/*.ts",
    "mocha": "mocha tests/*.ts tests/**/*.ts --require ts-node/register",
    "page-content": "npm run compile && rm -rf .ignore/ && mkdirp .ignore/ && npm run changelog && node tools/make-toc.js && node tools/make-factories.js && node tools/make-methods.js && cat markdown/header.md markdown/generated-toc.md markdown/overview.md markdown/generated-factories.md markdown/generated-methods.md markdown/footer.md > .ignore/content.md",
    "postdist": "node tools/minify.js",
    "postreadme": "npm run extra-docs",
    "postversion": "git push origin master && git push origin --tags && npm publish && npm run update-gh-pages",
    "predist": "rm -rf dist/ && mkdirp dist/ && npm run compile",
    "premocha": "npm run compile",
    "prepublish": "npm run compile",
    "preversion": "npm run readme && npm test",
    "readme": "npm run page-content && cat markdown/readme-title.md .ignore/content.md > README.md",
    "release": "./tools/release-if-necessary.sh",
    "release-major": "npm version major -m \"chore(package): release new version\"",
    "release-minor": "npm version minor -m \"chore(package): release new version\"",
    "release-patch": "false",
    "setup-browser-tests": "browserify browser-tests/index.ts -p [ tsify ] > browser-tests/tests-bundle.js",
    "start": "npm install && npm prune",
    "teardown-browser-tests": "rm browser-tests/tests-bundle.js",
    "test": "npm run lint && npm run test-types && npm run mocha && npm run doctest",
    "test-types": "tsc tests/types.ts --noEmit",
    "update-gh-pages": "git checkout gh-pages && rm _includes/content.md && cp .ignore/content.md _includes/ && git add --all && if git diff --cached --quiet > /dev/null; then :; else git commit -m \"update site\"; fi && git push origin gh-pages && git checkout master",
    "version": "npm run readme && npm run dist && git add -A"
  },
  "typings": "index.d.ts",
  "version": "11.7.0"
}
