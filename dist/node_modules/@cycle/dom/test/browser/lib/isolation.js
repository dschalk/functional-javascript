"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var assert = require("assert");
var isolate_1 = require("@cycle/isolate");
var xstream_1 = require("xstream");
var fromDiagram_1 = require("xstream/extra/fromDiagram");
var delay_1 = require("xstream/extra/delay");
var concat_1 = require("xstream/extra/concat");
var run_1 = require("@cycle/run");
var index_1 = require("../../../lib/cjs/index");
if (isIE10) {
    window.MutationObserver = require('mutation-observer');
}
function createRenderTarget(id) {
    if (id === void 0) { id = null; }
    var element = document.createElement('div');
    element.className = 'cycletest';
    if (id) {
        element.id = id;
    }
    document.body.appendChild(element);
    return element;
}
describe('isolateSource', function () {
    it('should have the same effect as DOM.select()', function (done) {
        function app(sources) {
            return {
                DOM: xstream_1.default.of(index_1.h3('.top-most', [
                    index_1.h2('.bar', 'Wrong'),
                    index_1.div({ isolate: 'foo' }, [index_1.h4('.bar', 'Correct')]),
                ])),
            };
        }
        var _a = run_1.setup(app, {
            DOM: index_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        var dispose;
        var isolatedDOMSource = sources.DOM.isolateSource(sources.DOM, 'foo');
        // Make assertions
        isolatedDOMSource
            .select('.bar')
            .elements()
            .drop(1)
            .take(1)
            .addListener({
            next: function (elements) {
                assert.strictEqual(elements.length, 1);
                var correctElement = elements[0];
                assert.notStrictEqual(correctElement, null);
                assert.notStrictEqual(typeof correctElement, 'undefined');
                assert.strictEqual(correctElement.tagName, 'H4');
                assert.strictEqual(correctElement.textContent, 'Correct');
                setTimeout(function () {
                    dispose();
                    done();
                });
            },
        });
        dispose = run();
    });
    it('should return source also with isolateSource and isolateSink', function (done) {
        function app(sources) {
            return {
                DOM: xstream_1.default.of(index_1.h('h3.top-most')),
            };
        }
        var _a = run_1.setup(app, {
            DOM: index_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        var dispose = run();
        var isolatedDOMSource = sources.DOM.isolateSource(sources.DOM, 'top-most');
        // Make assertions
        assert.strictEqual(typeof isolatedDOMSource.isolateSource, 'function');
        assert.strictEqual(typeof isolatedDOMSource.isolateSink, 'function');
        dispose();
        done();
    });
});
describe('isolateSink', function () {
    it('should add an isolate field to the vtree sink', function (done) {
        function app(sources) {
            var vtree$ = xstream_1.default.of(index_1.h3('.top-most'));
            return {
                DOM: sources.DOM.isolateSink(vtree$, 'foo'),
            };
        }
        var _a = run_1.setup(app, {
            DOM: index_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        var dispose;
        // Make assertions
        sinks.DOM.take(1).addListener({
            next: function (vtree) {
                assert.strictEqual(vtree.sel, 'h3.top-most');
                assert.strictEqual(vtree.data.isolate, 'foo');
                setTimeout(function () {
                    dispose();
                    done();
                });
            },
        });
        dispose = run();
    });
    it('should not redundantly repeat the scope className', function (done) {
        function app(sources) {
            var vtree1$ = xstream_1.default.of(index_1.span('.tab1', 'Hi'));
            var vtree2$ = xstream_1.default.of(index_1.span('.tab2', 'Hello'));
            var first$ = sources.DOM.isolateSink(vtree1$, '1');
            var second$ = sources.DOM.isolateSink(vtree2$, '2');
            var switched$ = concat_1.default(xstream_1.default.of(1).compose(delay_1.default(50)), xstream_1.default.of(2).compose(delay_1.default(50)), xstream_1.default.of(1).compose(delay_1.default(50)), xstream_1.default.of(2).compose(delay_1.default(50)), xstream_1.default.of(1).compose(delay_1.default(50)), xstream_1.default.of(2).compose(delay_1.default(50)))
                .map(function (i) { return (i === 1 ? first$ : second$); })
                .flatten();
            return {
                DOM: switched$,
            };
        }
        var _a = run_1.setup(app, {
            DOM: index_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        var dispose;
        // Make assertions
        sinks.DOM
            .drop(2)
            .take(1)
            .addListener({
            next: function (vtree) {
                assert.strictEqual(vtree.sel, 'span.tab1');
                assert.strictEqual(vtree.data.isolate, '1');
                dispose();
                done();
            },
        });
        dispose = run();
    });
});
describe('isolation', function () {
    it('should prevent parent from DOM.selecting() inside the isolation', function (done) {
        function app(sources) {
            var child$ = sources.DOM.isolateSink(xstream_1.default.of(index_1.div('.foo', [index_1.h4('.bar', 'Wrong')])), 'ISOLATION');
            var vdom$ = xstream_1.default
                .combine(xstream_1.default.of(null), child$)
                .map(function (_a) {
                var _ = _a[0], child = _a[1];
                return index_1.h3('.top-most', [child, index_1.h2('.bar', 'Correct')]);
            });
            return {
                DOM: vdom$,
            };
        }
        var _a = run_1.setup(app, {
            DOM: index_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        sources.DOM
            .select('.bar')
            .elements()
            .drop(1)
            .take(1)
            .addListener({
            next: function (elements) {
                assert.strictEqual(Array.isArray(elements), true);
                assert.strictEqual(elements.length, 1);
                var correctElement = elements[0];
                assert.notStrictEqual(correctElement, null);
                assert.notStrictEqual(typeof correctElement, 'undefined');
                assert.strictEqual(correctElement.tagName, 'H2');
                assert.strictEqual(correctElement.textContent, 'Correct');
                done();
            },
        });
        run();
    });
    it('should not occur with scope ":root"', function (done) {
        function app(sources) {
            var child$ = sources.DOM.isolateSink(xstream_1.default.of(index_1.div('.foo', [index_1.h4('.bar', 'Not wrong')])), ':root');
            var vdom$ = xstream_1.default
                .combine(xstream_1.default.of(null), child$)
                .map(function (_a) {
                var _ = _a[0], child = _a[1];
                return index_1.h3('.top-most', [child, index_1.h2('.bar', 'Correct')]);
            });
            return {
                DOM: vdom$,
            };
        }
        var _a = run_1.setup(app, {
            DOM: index_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        sources.DOM
            .select('.bar')
            .elements()
            .drop(1)
            .take(1)
            .addListener({
            next: function (elements) {
                assert.strictEqual(Array.isArray(elements), true);
                assert.strictEqual(elements.length, 2);
                var notWrongElement = elements[0];
                assert.notStrictEqual(notWrongElement, null);
                assert.notStrictEqual(typeof notWrongElement, 'undefined');
                assert.strictEqual(notWrongElement.tagName, 'H4');
                assert.strictEqual(notWrongElement.textContent, 'Not wrong');
                var correctElement = elements[1];
                assert.notStrictEqual(correctElement, null);
                assert.notStrictEqual(typeof correctElement, 'undefined');
                assert.strictEqual(correctElement.tagName, 'H2');
                assert.strictEqual(correctElement.textContent, 'Correct');
                done();
            },
        });
        run();
    });
    it('should apply only between siblings when given scope ".foo"', function (done) {
        function app(sources) {
            var foo$ = sources.DOM.isolateSink(xstream_1.default.of(index_1.div('.container', [index_1.h4('.header', 'Correct')])), '.foo');
            var bar$ = sources.DOM.isolateSink(xstream_1.default.of(index_1.div('.container', [index_1.h3('.header', 'Wrong')])), '.bar');
            var vdom$ = xstream_1.default
                .combine(foo$, bar$)
                .map(function (_a) {
                var foo = _a[0], bar = _a[1];
                return index_1.div('.top-most', [foo, bar, index_1.h2('.header', 'Correct')]);
            });
            return {
                DOM: vdom$,
            };
        }
        var _a = run_1.setup(app, {
            DOM: index_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        // Assert parent has total access to its children
        sources.DOM
            .select('.header')
            .elements()
            .drop(1)
            .take(1)
            .addListener({
            next: function (elements) {
                assert.strictEqual(Array.isArray(elements), true);
                assert.strictEqual(elements.length, 3);
                assert.strictEqual(elements[0].tagName, 'H4');
                assert.strictEqual(elements[0].textContent, 'Correct');
                assert.strictEqual(elements[1].tagName, 'H3');
                assert.strictEqual(elements[1].textContent, 'Wrong');
                assert.strictEqual(elements[2].tagName, 'H2');
                assert.strictEqual(elements[2].textContent, 'Correct');
                // Assert .foo child has no access to .bar child
                sources.DOM
                    .isolateSource(sources.DOM, '.foo')
                    .select('.header')
                    .elements()
                    .take(1)
                    .addListener({
                    next: function (els) {
                        assert.strictEqual(Array.isArray(els), true);
                        assert.strictEqual(els.length, 1);
                        assert.strictEqual(els[0].tagName, 'H4');
                        assert.strictEqual(els[0].textContent, 'Correct');
                        done();
                    },
                });
            },
        });
        run();
    });
    it('should apply only between siblings when given scope "#foo"', function (done) {
        function app(sources) {
            var foo$ = sources.DOM.isolateSink(xstream_1.default.of(index_1.div('.container', [index_1.h4('.header', 'Correct')])), '#foo');
            var bar$ = sources.DOM.isolateSink(xstream_1.default.of(index_1.div('.container', [index_1.h3('.header', 'Wrong')])), '#bar');
            var vdom$ = xstream_1.default
                .combine(foo$, bar$)
                .map(function (_a) {
                var foo = _a[0], bar = _a[1];
                return index_1.div('.top-most', [foo, bar, index_1.h2('.header', 'Correct')]);
            });
            return {
                DOM: vdom$,
            };
        }
        var _a = run_1.setup(app, {
            DOM: index_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        // Assert parent has total access to its children
        sources.DOM
            .select('.header')
            .elements()
            .drop(1)
            .take(1)
            .addListener({
            next: function (elements) {
                assert.strictEqual(Array.isArray(elements), true);
                assert.strictEqual(elements.length, 3);
                assert.strictEqual(elements[0].tagName, 'H4');
                assert.strictEqual(elements[0].textContent, 'Correct');
                assert.strictEqual(elements[1].tagName, 'H3');
                assert.strictEqual(elements[1].textContent, 'Wrong');
                assert.strictEqual(elements[2].tagName, 'H2');
                assert.strictEqual(elements[2].textContent, 'Correct');
                // Assert .foo child has no access to .bar child
                sources.DOM
                    .isolateSource(sources.DOM, '#foo')
                    .select('.header')
                    .elements()
                    .take(1)
                    .addListener({
                    next: function (els) {
                        assert.strictEqual(Array.isArray(els), true);
                        assert.strictEqual(els.length, 1);
                        assert.strictEqual(els[0].tagName, 'H4');
                        assert.strictEqual(els[0].textContent, 'Correct');
                        done();
                    },
                });
            },
        });
        run();
    });
    it('should work with thunks', function (done) {
        function app(sources) {
            var child$ = sources.DOM.isolateSink(xstream_1.default.of(index_1.thunk('div.foo', function () { return index_1.div('.foo', [index_1.h4('.bar', 'Wrong')]); }, [])), 'ISOLATION');
            var vdom$ = xstream_1.default
                .combine(xstream_1.default.of(null), child$)
                .map(function (_a) {
                var _ = _a[0], child = _a[1];
                return index_1.h3('.top-most', [child, index_1.h2('.bar', 'Correct')]);
            });
            return {
                DOM: vdom$,
            };
        }
        var _a = run_1.setup(app, {
            DOM: index_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        sources.DOM
            .select('.bar')
            .elements()
            .drop(1)
            .take(1)
            .addListener({
            next: function (elements) {
                assert.strictEqual(Array.isArray(elements), true);
                assert.strictEqual(elements.length, 1);
                var correctElement = elements[0];
                assert.notStrictEqual(correctElement, null);
                assert.notStrictEqual(typeof correctElement, 'undefined');
                assert.strictEqual(correctElement.tagName, 'H2');
                assert.strictEqual(correctElement.textContent, 'Correct');
                done();
            },
        });
        run();
    });
    it('should allow using elements() in an isolated main() fn', function (done) {
        function main(sources) {
            var elem$ = sources.DOM.select(':root').elements();
            var vnode$ = elem$.map(function (elem) {
                return index_1.h('div.bar', 'left=' + elem[0].offsetLeft);
            });
            return {
                DOM: vnode$,
            };
        }
        var _a = run_1.setup(isolate_1.default(main), {
            DOM: index_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        sources.DOM
            .select(':root')
            .element()
            .drop(1)
            .take(1)
            .addListener({
            next: function (root) {
                var barElem = root.querySelector('.bar');
                assert.notStrictEqual(barElem, null);
                assert.notStrictEqual(typeof barElem, 'undefined');
                assert.strictEqual(barElem.tagName, 'DIV');
                assert.strictEqual(barElem.textContent, 'left=0');
                done();
            },
        });
        run();
    });
    it('should allow parent to DOM.select() in its own isolation island', function (done) {
        function app(sources) {
            var _a = sources.DOM, isolateSource = _a.isolateSource, isolateSink = _a.isolateSink;
            var islandElement$ = isolateSource(sources.DOM, 'island')
                .select('.bar')
                .elements();
            var islandVDom$ = sources.DOM.isolateSink(xstream_1.default.of(index_1.div([index_1.h3('.bar', 'Correct')])), 'island');
            var child$ = sources.DOM.isolateSink(islandVDom$.map(function (islandVDom) {
                return index_1.div('.foo', [islandVDom, index_1.h4('.bar', 'Wrong')]);
            }), 'ISOLATION');
            var vdom$ = child$.map(function (child) { return index_1.h3('.top-most', [child]); });
            return {
                DOM: vdom$,
                island: islandElement$,
            };
        }
        var _a = run_1.setup(app, {
            DOM: index_1.makeDOMDriver(createRenderTarget()),
            island: function (sink) { },
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        sinks.island
            .drop(1)
            .take(1)
            .addListener({
            next: function (elements) {
                assert.strictEqual(Array.isArray(elements), true);
                assert.strictEqual(elements.length, 1);
                var correctElement = elements[0];
                assert.notStrictEqual(correctElement, null);
                assert.notStrictEqual(typeof correctElement, 'undefined');
                assert.strictEqual(correctElement.tagName, 'H3');
                assert.strictEqual(correctElement.textContent, 'Correct');
                done();
            },
        });
        run();
    });
    it('should isolate DOM.select between parent and (wrapper) child', function (done) {
        function Frame(sources) {
            var click$ = sources.DOM.select('.foo').events('click');
            var vdom$ = sources.content$.map(function (content) {
                return index_1.h4('.foo.frame', { style: { backgroundColor: 'lightblue' } }, [content]);
            });
            return {
                DOM: vdom$,
                click$: click$,
            };
        }
        function Monalisa(sources) {
            var _a = sources.DOM, isolateSource = _a.isolateSource, isolateSink = _a.isolateSink;
            var islandDOMSource = isolateSource(sources.DOM, 'island');
            var click$ = islandDOMSource.select('.foo').events('click');
            var islandDOMSink$ = isolateSink(xstream_1.default.of(index_1.span('.foo.monalisa', 'Monalisa')), 'island');
            var frameDOMSource = isolateSource(sources.DOM, 'myFrame');
            var frame = Frame({ DOM: frameDOMSource, content$: islandDOMSink$ });
            var outerVTree$ = isolateSink(frame.DOM, 'myFrame');
            return {
                DOM: outerVTree$,
                frameClick: frame.click$,
                monalisaClick: click$,
            };
        }
        var _a = run_1.setup(Monalisa, {
            DOM: index_1.makeDOMDriver(createRenderTarget()),
            frameClick: function (sink) { },
            monalisaClick: function (sink) { },
        }), sources = _a.sources, sinks = _a.sinks, run = _a.run;
        var dispose;
        var frameClick$ = sinks.frameClick.map(function (ev) { return ({
            type: ev.type,
            tagName: ev.target.tagName,
        }); });
        var monalisaClick$ = sinks.monalisaClick.map(function (ev) { return ({
            type: ev.type,
            tagName: ev.target.tagName,
        }); });
        // Stop the propagtion of the first click
        sinks.monalisaClick.take(1).addListener({
            next: function (ev) { return ev.stopPropagation(); },
        });
        // The frame should be notified about 2 clicks:
        //  1. the second click on monalisa (whose propagation has not stopped)
        //  2. the only click on the frame itself
        var expected = [
            { type: 'click', tagName: 'SPAN' },
            { type: 'click', tagName: 'H4' },
        ];
        frameClick$.take(2).addListener({
            next: function (event) {
                var e = expected.shift();
                assert.strictEqual(event.type, e.type);
                assert.strictEqual(event.tagName, e.tagName);
                if (expected.length === 0) {
                    dispose();
                    done();
                }
            },
        });
        // Monalisa should receive two clicks
        var otherExpected = [
            { type: 'click', tagName: 'SPAN' },
            { type: 'click', tagName: 'SPAN' },
        ];
        monalisaClick$.take(2).addListener({
            next: function (event) {
                var e = otherExpected.shift();
                assert.strictEqual(event.type, e.type);
                assert.strictEqual(event.tagName, e.tagName);
            },
        });
        sources.DOM
            .select(':root')
            .element()
            .drop(1)
            .take(1)
            .addListener({
            next: function (root) {
                var frameFoo = root.querySelector('.foo.frame');
                var monalisaFoo = root.querySelector('.foo.monalisa');
                assert.notStrictEqual(frameFoo, null);
                assert.notStrictEqual(monalisaFoo, null);
                assert.notStrictEqual(typeof frameFoo, 'undefined');
                assert.notStrictEqual(typeof monalisaFoo, 'undefined');
                assert.strictEqual(frameFoo.tagName, 'H4');
                assert.strictEqual(monalisaFoo.tagName, 'SPAN');
                assert.doesNotThrow(function () {
                    setTimeout(function () { return monalisaFoo.click(); });
                    setTimeout(function () { return monalisaFoo.click(); });
                    setTimeout(function () { return frameFoo.click(); }, 0);
                });
            },
        });
        dispose = run();
    });
    it('should allow a child component to DOM.select() its own root', function (done) {
        function app(sources) {
            var child$ = sources.DOM.isolateSink(xstream_1.default.of(index_1.span('.foo', [index_1.h4('.bar', 'Wrong')])), 'ISOLATION');
            return {
                DOM: child$.map(function (child) { return index_1.h3('.top-most', [child]); }),
            };
        }
        var _a = run_1.setup(app, {
            DOM: index_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        var isolateSource = sources.DOM.isolateSource;
        var dispose;
        isolateSource(sources.DOM, 'ISOLATION')
            .select('.foo')
            .elements()
            .drop(1)
            .take(1)
            .addListener({
            next: function (elements) {
                assert.strictEqual(Array.isArray(elements), true);
                assert.strictEqual(elements.length, 1);
                var correctElement = elements[0];
                assert.notStrictEqual(correctElement, null);
                assert.notStrictEqual(typeof correctElement, 'undefined');
                assert.strictEqual(correctElement.tagName, 'SPAN');
                setTimeout(function () {
                    dispose();
                    done();
                });
            },
        });
        dispose = run();
    });
    it('should allow DOM.selecting svg elements', function (done) {
        function App(sources) {
            var triangleElement$ = sources.DOM.select('.triangle').elements();
            var svgTriangle = index_1.svg({ attrs: { width: 150, height: 150 } }, [
                index_1.svg.polygon({
                    attrs: {
                        class: 'triangle',
                        points: '20 0 20 150 150 20',
                    },
                }),
            ]);
            return {
                DOM: xstream_1.default.of(svgTriangle),
                triangleElement: triangleElement$,
            };
        }
        function IsolatedApp(sources) {
            var _a = sources.DOM, isolateSource = _a.isolateSource, isolateSink = _a.isolateSink;
            var isolatedDOMSource = isolateSource(sources.DOM, 'ISOLATION');
            var app = App({ DOM: isolatedDOMSource });
            var isolateDOMSink = isolateSink(app.DOM, 'ISOLATION');
            return {
                DOM: isolateDOMSink,
                triangleElement: app.triangleElement,
            };
        }
        var _a = run_1.setup(IsolatedApp, {
            DOM: index_1.makeDOMDriver(createRenderTarget()),
            triangleElement: function (sink) { },
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        // Make assertions
        sinks.triangleElement
            .drop(1)
            .take(1)
            .addListener({
            next: function (elements) {
                assert.strictEqual(elements.length, 1);
                var triangleElement = elements[0];
                assert.notStrictEqual(triangleElement, null);
                assert.notStrictEqual(typeof triangleElement, 'undefined');
                assert.strictEqual(triangleElement.tagName, 'polygon');
                done();
            },
        });
        run();
    });
    it('should allow DOM.select()ing its own root without classname or id', function (done) {
        function app(sources) {
            var child$ = sources.DOM.isolateSink(xstream_1.default.of(index_1.span([index_1.h4('.bar', 'Wrong')])), 'ISOLATION');
            return {
                DOM: child$.map(function (child) { return index_1.h3('.top-most', [child]); }),
            };
        }
        var _a = run_1.setup(app, {
            DOM: index_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        var isolateSource = sources.DOM.isolateSource;
        isolateSource(sources.DOM, 'ISOLATION')
            .select('span')
            .elements()
            .drop(1)
            .take(1)
            .addListener({
            next: function (elements) {
                assert.strictEqual(Array.isArray(elements), true);
                assert.strictEqual(elements.length, 1);
                var correctElement = elements[0];
                assert.notStrictEqual(correctElement, null);
                assert.notStrictEqual(typeof correctElement, 'undefined');
                assert.strictEqual(correctElement.tagName, 'SPAN');
                done();
            },
        });
        run();
    });
    it('should allow DOM.select()ing all elements with `*`', function (done) {
        function app(sources) {
            var child$ = sources.DOM.isolateSink(xstream_1.default.of(index_1.span([index_1.div([index_1.h4('.foo', 'hello'), index_1.h4('.bar', 'world')])])), 'ISOLATION');
            return {
                DOM: child$.map(function (child) { return index_1.h3('.top-most', [child]); }),
            };
        }
        var _a = run_1.setup(app, {
            DOM: index_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        var isolateSource = sources.DOM.isolateSource;
        isolateSource(sources.DOM, 'ISOLATION')
            .select('*')
            .elements()
            .drop(1)
            .take(1)
            .addListener({
            next: function (elements) {
                assert.strictEqual(Array.isArray(elements), true);
                assert.strictEqual(elements.length, 4);
                done();
            },
        });
        run();
    });
    it('should select() isolated element with tag + class', function (done) {
        function app(sources) {
            return {
                DOM: xstream_1.default.of(index_1.h3('.top-most', [
                    index_1.h2('.bar', 'Wrong'),
                    index_1.div({ isolate: 'foo' }, [index_1.h4('.bar', 'Correct')]),
                ])),
            };
        }
        var _a = run_1.setup(app, {
            DOM: index_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        var isolatedDOMSource = sources.DOM.isolateSource(sources.DOM, 'foo');
        // Make assertions
        isolatedDOMSource
            .select('h4.bar')
            .elements()
            .drop(1)
            .take(1)
            .addListener({
            next: function (elements) {
                assert.strictEqual(elements.length, 1);
                var correctElement = elements[0];
                assert.notStrictEqual(correctElement, null);
                assert.notStrictEqual(typeof correctElement, 'undefined');
                assert.strictEqual(correctElement.tagName, 'H4');
                assert.strictEqual(correctElement.textContent, 'Correct');
                done();
            },
        });
        run();
    });
    it('should allow isolatedDOMSource.events() to work without crashing', function (done) {
        function app(sources) {
            return {
                DOM: xstream_1.default.of(index_1.h3('.top-most', [index_1.div({ isolate: 'foo' }, [index_1.h4('.bar', 'Hello')])])),
            };
        }
        var _a = run_1.setup(app, {
            DOM: index_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        var dispose;
        var isolatedDOMSource = sources.DOM.isolateSource(sources.DOM, 'foo');
        isolatedDOMSource.events('click').addListener({
            next: function (ev) {
                dispose();
                done();
            },
        });
        // Make assertions
        isolatedDOMSource
            .select('div')
            .elements()
            .drop(1)
            .take(1)
            .addListener({
            next: function (elements) {
                assert.strictEqual(elements.length, 1);
                var correctElement = elements[0];
                assert.notStrictEqual(correctElement, null);
                assert.notStrictEqual(typeof correctElement, 'undefined');
                assert.strictEqual(correctElement.tagName, 'DIV');
                assert.strictEqual(correctElement.textContent, 'Hello');
                setTimeout(function () {
                    correctElement.click();
                });
            },
        });
        dispose = run();
    });
    it('should process bubbling events from inner to outer component', function (done) {
        function app(sources) {
            return {
                DOM: xstream_1.default.of(index_1.h3('.top-most', [
                    index_1.h2('.bar', 'Wrong'),
                    index_1.div({ isolate: 'foo' }, [index_1.h4('.bar', 'Correct')]),
                ])),
            };
        }
        var _a = run_1.setup(app, {
            DOM: index_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        var dispose;
        var isolatedDOMSource = sources.DOM.isolateSource(sources.DOM, 'foo');
        var called = false;
        sources.DOM
            .select('.top-most')
            .events('click')
            .addListener({
            next: function (ev) {
                assert.strictEqual(called, true);
                dispose();
                done();
            },
        });
        isolatedDOMSource
            .select('h4.bar')
            .events('click')
            .addListener({
            next: function (ev) {
                assert.strictEqual(called, false);
                called = true;
            },
        });
        // Make assertions
        isolatedDOMSource
            .select('h4.bar')
            .elements()
            .drop(1)
            .take(1)
            .addListener({
            next: function (elements) {
                assert.strictEqual(elements.length, 1);
                var correctElement = elements[0];
                assert.notStrictEqual(correctElement, null);
                assert.notStrictEqual(typeof correctElement, 'undefined');
                assert.strictEqual(correctElement.tagName, 'H4');
                assert.strictEqual(correctElement.textContent, 'Correct');
                setTimeout(function () {
                    correctElement.click();
                });
            },
        });
        dispose = run();
    });
    it('should stop bubbling the event if the currentTarget was removed', function (done) {
        function main(sources) {
            var childExistence$ = sources.DOM
                .isolateSource(sources.DOM, 'foo')
                .select('h4.bar')
                .events('click')
                .map(function () { return false; })
                .startWith(true);
            return {
                DOM: childExistence$.map(function (exists) {
                    return index_1.div([
                        index_1.div('.top-most', { isolate: 'top' }, [
                            index_1.h2('.bar', 'Wrong'),
                            exists ? index_1.div({ isolate: 'foo' }, [index_1.h4('.bar', 'Correct')]) : null,
                        ]),
                    ]);
                }),
            };
        }
        var _a = run_1.setup(main, {
            DOM: index_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        var dispose;
        var topDOMSource = sources.DOM.isolateSource(sources.DOM, 'top');
        var fooDOMSource = sources.DOM.isolateSource(sources.DOM, 'foo');
        var parentEventHandlerCalled = false;
        topDOMSource
            .select('.bar')
            .events('click')
            .addListener({
            next: function (ev) {
                parentEventHandlerCalled = true;
                done('this should not be called');
            },
        });
        // Make assertions
        fooDOMSource
            .select('.bar')
            .elements()
            .drop(1)
            .take(1)
            .addListener({
            next: function (elements) {
                assert.strictEqual(elements.length, 1);
                var correctElement = elements[0];
                assert.notStrictEqual(correctElement, null);
                assert.notStrictEqual(typeof correctElement, 'undefined');
                assert.strictEqual(correctElement.tagName, 'H4');
                assert.strictEqual(correctElement.textContent, 'Correct');
                setTimeout(function () {
                    correctElement.click();
                    setTimeout(function () {
                        assert.strictEqual(parentEventHandlerCalled, false);
                        dispose();
                        done();
                    }, 150);
                });
            },
        });
        dispose = run();
    });
    it('should handle a higher-order graph when events() are subscribed', function (done) {
        var errorHappened = false;
        var clickDetected = false;
        function Child(sources) {
            return {
                DOM: sources.DOM
                    .select('.foo')
                    .events('click')
                    .debug(function () {
                    clickDetected = true;
                })
                    .replaceError(function () {
                    errorHappened = true;
                    return xstream_1.default.empty();
                })
                    .mapTo(1)
                    .startWith(0)
                    .map(function (num) { return index_1.div('.container', [index_1.h3('.foo', 'Child foo')]); }),
            };
        }
        function main(sources) {
            var first = isolate_1.default(Child, 'first')(sources);
            var second = isolate_1.default(Child, 'second')(sources);
            var oneChild = [first];
            var twoChildren = [first, second];
            var vnode$ = xstream_1.default
                .periodic(50)
                .take(1)
                .startWith(-1)
                .map(function (i) { return (i === -1 ? oneChild : twoChildren); })
                .map(function (children) {
                return xstream_1.default
                    .combine.apply(xstream_1.default, children.map(function (child) { return child.DOM; })).map(function (childVNodes) { return index_1.div('.parent', childVNodes); });
            })
                .flatten();
            return {
                DOM: vnode$,
            };
        }
        var _a = run_1.setup(main, {
            DOM: index_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        var dispose;
        sources.DOM
            .select(':root')
            .element()
            .drop(2)
            .take(1)
            .addListener({
            next: function (root) {
                var parentEl = root.querySelector('.parent');
                var foo = parentEl.querySelectorAll('.foo')[1];
                assert.notStrictEqual(parentEl, null);
                assert.notStrictEqual(typeof parentEl, 'undefined');
                assert.notStrictEqual(foo, null);
                assert.notStrictEqual(typeof foo, 'undefined');
                assert.strictEqual(parentEl.tagName, 'DIV');
                setTimeout(function () {
                    assert.strictEqual(errorHappened, false);
                    foo.click();
                    setTimeout(function () {
                        assert.strictEqual(clickDetected, true);
                        dispose();
                        done();
                    }, 50);
                }, 100);
            },
        });
        dispose = run();
    });
    it('should handle events when child is removed and re-added', function (done) {
        var clicksCount = 0;
        function Child(sources) {
            sources.DOM
                .select('.foo')
                .events('click')
                .addListener({
                next: function () {
                    clicksCount++;
                },
            });
            return {
                DOM: xstream_1.default.of(index_1.div('.foo', ['This is foo'])),
            };
        }
        function main(sources) {
            var child = isolate_1.default(Child)(sources);
            // make child.DOM be inserted, removed, and inserted again
            var innerDOM$ = xstream_1.default
                .periodic(120)
                .take(2)
                .map(function (x) { return x + 1; })
                .startWith(0)
                .map(function (x) { return (x === 1 ? xstream_1.default.of(index_1.div()) : child.DOM); })
                .flatten();
            return {
                DOM: innerDOM$,
            };
        }
        var _a = run_1.setup(main, {
            DOM: index_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        var dispose;
        sources.DOM
            .select(':root')
            .element()
            .drop(1)
            .take(3)
            .addListener({
            next: function (root) {
                setTimeout(function () {
                    var foo = root.querySelector('.foo');
                    if (!foo) {
                        return;
                    }
                    foo.click();
                }, 0);
            },
        });
        setTimeout(function () {
            assert.strictEqual(clicksCount, 2);
            dispose();
            done();
        }, 500);
        dispose = run();
    });
    it('should handle events when parent is removed and re-added', function (done) {
        var clicksCount = 0;
        function Child(sources) {
            sources.DOM
                .select('.foo')
                .events('click')
                .addListener({
                next: function () {
                    clicksCount++;
                },
            });
            return {
                DOM: xstream_1.default.of(index_1.div('.foo', ['This is foo'])),
            };
        }
        function main(sources) {
            var child = isolate_1.default(Child, 'child')(sources);
            // change parent key, causing it to be recreated
            var x$ = xstream_1.default
                .periodic(120)
                .map(function (x) { return x + 1; })
                .startWith(0)
                .take(4);
            var innerDOM$ = xstream_1.default
                .combine(x$, child.DOM)
                .map(function (_a) {
                var x = _a[0], childVDOM = _a[1];
                return index_1.div(".parent" + x, { key: "key" + x }, [childVDOM, "" + x]);
            });
            return {
                DOM: innerDOM$,
            };
        }
        var _a = run_1.setup(main, {
            DOM: index_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        var dispose;
        sources.DOM
            .select(':root')
            .element()
            .drop(1)
            .take(4)
            .addListener({
            next: function (root) {
                setTimeout(function () {
                    var foo = root.querySelector('.foo');
                    if (!foo) {
                        return;
                    }
                    foo.click();
                }, 0);
            },
        });
        setTimeout(function () {
            assert.strictEqual(clicksCount, 4);
            dispose();
            done();
        }, 800);
        dispose = run();
    });
    it('should handle events when parent is removed and re-added, and has isolation scope', function (done) {
        var clicksCount = 0;
        function Child(sources) {
            sources.DOM
                .select('.foo')
                .events('click')
                .addListener({
                next: function () {
                    clicksCount++;
                },
            });
            return {
                DOM: xstream_1.default.of(index_1.div('.foo', ['This is foo'])),
            };
        }
        function Parent(sources) {
            var child = isolate_1.default(Child, 'child')(sources);
            // change parent key, causing it to be recreated
            var x$ = xstream_1.default
                .periodic(120)
                .map(function (x) { return x + 1; })
                .startWith(0)
                .take(4);
            var innerDOM$ = xstream_1.default
                .combine(x$, child.DOM)
                .map(function (_a) {
                var x = _a[0], childVDOM = _a[1];
                return index_1.div(".parent" + x, { key: "key" + x }, [childVDOM, "" + x]);
            });
            return {
                DOM: innerDOM$,
            };
        }
        function main(sources) {
            var parent = isolate_1.default(Parent, 'parent')(sources);
            return {
                DOM: parent.DOM,
            };
        }
        var _a = run_1.setup(main, {
            DOM: index_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        var dispose;
        sources.DOM
            .select(':root')
            .element()
            .drop(1)
            .take(4)
            .addListener({
            next: function (root) {
                setTimeout(function () {
                    var foo = root.querySelector('.foo');
                    if (!foo) {
                        return;
                    }
                    foo.click();
                }, 0);
            },
        });
        setTimeout(function () {
            assert.strictEqual(clicksCount, 4);
            dispose();
            done();
        }, 800);
        dispose = run();
    });
    it('should allow an isolated child to receive events when it is used as ' +
        'the vTree of an isolated parent component', function (done) {
        var dispose;
        function Component(sources) {
            sources.DOM
                .select('.btn')
                .events('click')
                .addListener({
                next: function (ev) {
                    assert.strictEqual(ev.target.tagName, 'BUTTON');
                    dispose();
                    done();
                },
            });
            return {
                DOM: xstream_1.default.of(index_1.div('.component', {}, [index_1.button('.btn', {}, 'Hello')])),
            };
        }
        function main(sources) {
            var component = isolate_1.default(Component)(sources);
            return { DOM: component.DOM };
        }
        function app(sources) {
            return isolate_1.default(main)(sources);
        }
        var _a = run_1.setup(app, {
            DOM: index_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        sources.DOM
            .element()
            .drop(1)
            .take(1)
            .addListener({
            next: function (root) {
                var element = root.querySelector('.btn');
                assert.notStrictEqual(element, null);
                setTimeout(function () { return element.click(); });
            },
        });
        dispose = run();
    });
    it('should allow an isolated child to receive events when it is used as ' +
        'the vTree of an isolated parent component when scope is explicitly ' +
        'specified on child', function (done) {
        var dispose;
        function Component(sources) {
            sources.DOM
                .select('.btn')
                .events('click')
                .addListener({
                next: function (ev) {
                    assert.strictEqual(ev.target.tagName, 'BUTTON');
                    dispose();
                    done();
                },
            });
            return {
                DOM: xstream_1.default.of(index_1.div('.component', {}, [index_1.button('.btn', {}, 'Hello')])),
            };
        }
        function main(sources) {
            var component = isolate_1.default(Component, 'foo')(sources);
            return { DOM: component.DOM };
        }
        function app(sources) {
            return isolate_1.default(main)(sources);
        }
        var _a = run_1.setup(app, {
            DOM: index_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        sources.DOM
            .element()
            .drop(1)
            .take(1)
            .addListener({
            next: function (root) {
                var element = root.querySelector('.btn');
                assert.notStrictEqual(element, null);
                setTimeout(function () { return element.click(); });
            },
        });
        dispose = run();
    });
    it('should allow an isolated child to receive events when it is used as ' +
        'the vTree of an isolated parent component when scope is explicitly ' +
        'specified on parent', function (done) {
        var dispose;
        function Component(sources) {
            sources.DOM
                .select('.btn')
                .events('click')
                .addListener({
                next: function (ev) {
                    assert.strictEqual(ev.target.tagName, 'BUTTON');
                    dispose();
                    done();
                },
            });
            return {
                DOM: xstream_1.default.of(index_1.div('.component', {}, [index_1.button('.btn', {}, 'Hello')])),
            };
        }
        function main(sources) {
            var component = isolate_1.default(Component)(sources);
            return { DOM: component.DOM };
        }
        function app(sources) {
            return isolate_1.default(main, 'foo')(sources);
        }
        var _a = run_1.setup(app, {
            DOM: index_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        sources.DOM
            .element()
            .drop(1)
            .take(1)
            .addListener({
            next: function (root) {
                var element = root.querySelector('.btn');
                assert.notStrictEqual(element, null);
                setTimeout(function () { return element.click(); });
            },
        });
        dispose = run();
    });
    it('should allow an isolated child to receive events when it is used as ' +
        'the vTree of an isolated parent component when scope is explicitly ' +
        'specified on parent and child', function (done) {
        var dispose;
        function Component(sources) {
            sources.DOM
                .select('.btn')
                .events('click')
                .addListener({
                next: function (ev) {
                    assert.strictEqual(ev.target.tagName, 'BUTTON');
                    dispose();
                    done();
                },
            });
            return {
                DOM: xstream_1.default.of(index_1.div('.component', {}, [index_1.button('.btn', {}, 'Hello')])),
            };
        }
        function main(sources) {
            var component = isolate_1.default(Component, 'bar')(sources);
            return { DOM: component.DOM };
        }
        function app(sources) {
            return isolate_1.default(main, 'foo')(sources);
        }
        var _a = run_1.setup(app, {
            DOM: index_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        sources.DOM
            .element()
            .drop(1)
            .take(1)
            .addListener({
            next: function (root) {
                var element = root.querySelector('.btn');
                assert.notStrictEqual(element, null);
                setTimeout(function () { return element.click(); });
            },
        });
        dispose = run();
    });
    it('should maintain virtual DOM list sanity using keys, in a list of ' +
        'isolated components', function (done) {
        var componentRemove$ = xstream_1.default.create();
        function Component(sources) {
            sources.DOM
                .select('.btn')
                .events('click')
                .addListener({
                next: function (ev) {
                    componentRemove$.shamefullySendNext(null);
                },
            });
            return {
                DOM: xstream_1.default.of(index_1.div('.component', {}, [index_1.button('.btn', {}, 'Hello')])),
            };
        }
        function main(sources) {
            var remove$ = componentRemove$
                .compose(delay_1.default(50))
                .fold(function (acc) { return acc + 1; }, 0);
            var first = isolate_1.default(Component, 'first')(sources);
            var second = isolate_1.default(Component, 'second')(sources);
            var vdom$ = xstream_1.default
                .combine(first.DOM, second.DOM, remove$)
                .map(function (_a) {
                var vdom1 = _a[0], vdom2 = _a[1], r = _a[2];
                if (r === 0) {
                    return index_1.div([vdom1, vdom2]);
                }
                else if (r === 1) {
                    return index_1.div([vdom2]);
                }
                else if (r === 2) {
                    return index_1.div([]);
                }
                else {
                    done('This case must not happen.');
                }
            });
            return { DOM: vdom$ };
        }
        var _a = run_1.setup(main, {
            DOM: index_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        var dispose;
        sources.DOM
            .element()
            .drop(1)
            .take(1)
            .addListener({
            next: function (root) {
                var components = root.querySelectorAll('.btn');
                assert.strictEqual(components.length, 2);
                var firstElement = components[0];
                var secondElement = components[1];
                setTimeout(function () {
                    firstElement.click();
                }, 100);
                setTimeout(function () {
                    secondElement.click();
                }, 300);
                setTimeout(function () {
                    assert.strictEqual(root.querySelectorAll('.component').length, 0);
                    dispose();
                    done();
                }, 500);
            },
        });
        dispose = run();
    });
    it('should allow null or undefined isolated child DOM', function (done) {
        function child(sources) {
            var visible$ = xstream_1.default
                .periodic(50)
                .take(1)
                .fold(function (acc, _) { return !acc; }, true);
            var vdom$ = visible$.map(function (visible) { return (visible ? index_1.h4('child') : null); });
            return {
                DOM: vdom$,
            };
        }
        function main(sources) {
            var childSinks = isolate_1.default(child, 'child')(sources);
            var vdom$ = childSinks.DOM.map(function (childVDom) {
                return index_1.div('.parent', [childVDom, index_1.h2('part of parent')]);
            });
            return {
                DOM: vdom$,
            };
        }
        var _a = run_1.setup(main, {
            DOM: index_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        var dispose;
        sources.DOM
            .element()
            .drop(1)
            .take(1)
            .addListener({
            next: function (root) {
                var parentEl = root.querySelector('.parent');
                assert.strictEqual(parentEl.childNodes.length, 2);
                assert.strictEqual(parentEl.children[0].tagName, 'H4');
                assert.strictEqual(parentEl.children[0].textContent, 'child');
                assert.strictEqual(parentEl.children[1].tagName, 'H2');
                assert.strictEqual(parentEl.children[1].textContent, 'part of parent');
            },
        });
        sources.DOM
            .element()
            .drop(2)
            .take(1)
            .addListener({
            next: function (root) {
                var parentEl = root.querySelector('.parent');
                assert.strictEqual(parentEl.childNodes.length, 1);
                assert.strictEqual(parentEl.children[0].tagName, 'H2');
                assert.strictEqual(parentEl.children[0].textContent, 'part of parent');
                dispose();
                done();
            },
        });
        dispose = run();
    });
    it('should allow recursive isolation using the same scope', function (done) {
        function Item(sources, count) {
            var childVdom$ = count > 0
                ? isolate_1.default(Item, '0')(sources, count - 1).DOM
                : xstream_1.default.of(null);
            var highlight$ = sources.DOM
                .select('button')
                .events('click')
                .mapTo(true)
                .fold(function (x, _) { return !x; }, false);
            var vdom$ = xstream_1.default
                .combine(childVdom$, highlight$)
                .map(function (_a) {
                var childVdom = _a[0], highlight = _a[1];
                return index_1.div([
                    index_1.button('.btn', highlight ? 'HIGHLIGHTED' : 'click me'),
                    childVdom,
                ]);
            });
            return { DOM: vdom$ };
        }
        function main(sources) {
            var vdom$ = Item(sources, 3).DOM;
            return { DOM: vdom$ };
        }
        var _a = run_1.setup(main, {
            DOM: index_1.makeDOMDriver(createRenderTarget()),
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        var dispose;
        sources.DOM
            .element()
            .drop(1)
            .take(1)
            .addListener({
            next: function (root) {
                var buttons = root.querySelectorAll('.btn');
                assert.strictEqual(buttons.length, 4);
                var firstButton = buttons[0];
                var secondButton = buttons[1];
                var thirdButton = buttons[2];
                var forthButton = buttons[3];
                setTimeout(function () {
                    thirdButton.click();
                }, 100);
                setTimeout(function () {
                    assert.notStrictEqual(firstButton.textContent, 'HIGHLIGHTED');
                    assert.notStrictEqual(secondButton.textContent, 'HIGHLIGHTED');
                    assert.strictEqual(thirdButton.textContent, 'HIGHLIGHTED');
                    assert.notStrictEqual(forthButton.textContent, 'HIGHLIGHTED');
                    dispose();
                    done();
                }, 300);
            },
        });
        dispose = run();
    });
    it('should not lose event delegators when components are moved around', function (done) {
        function component(sources) {
            var click$ = sources.DOM
                .select('.click-me')
                .events('click')
                .mapTo('clicked');
            return {
                DOM: xstream_1.default.of(index_1.button('.click-me', 'click me')),
                click$: click$,
            };
        }
        function app(sources) {
            var comp = isolate_1.default(component, 'child')(sources);
            var position$ = fromDiagram_1.default('1-2|');
            return {
                DOM: xstream_1.default.combine(position$, comp.DOM).map(function (_a) {
                    var position = _a[0], childDom = _a[1];
                    var children = position === '1'
                        ? [index_1.div([childDom]), index_1.div()]
                        : [index_1.div(), index_1.div([childDom])];
                    return index_1.div(children);
                }),
                click$: comp.click$,
            };
        }
        var _a = run_1.setup(app, {
            DOM: index_1.makeDOMDriver(createRenderTarget()),
            click$: function () { },
        }), sinks = _a.sinks, sources = _a.sources, run = _a.run;
        var expectedClicks = ['clicked', 'clicked'];
        var dispose;
        sinks.click$.take(2).addListener({
            next: function (message) {
                assert.strictEqual(message, expectedClicks.shift());
            },
            complete: function () {
                assert.strictEqual(expectedClicks.length, 0);
                done();
                dispose();
            },
        });
        sources.DOM
            .select(':root')
            .element()
            .drop(1)
            .addListener({
            next: function (root) {
                var button = root.querySelector('button.click-me');
                button.click();
            },
        });
        dispose = run();
    });
});
